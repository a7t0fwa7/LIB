; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28508.3 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1BI@MCHDAEEC@?$AA?$CF?$AAx?$AA?4?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAp?$AA?5?$AA?$CF?$AAS@ ; `string'
PUBLIC	??_C@_1M@JGIJAGIL@?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAS@ ; `string'
PUBLIC	?g_protMax@NT@@3KA				; NT::g_protMax
PUBLIC	?g_protMask@NT@@3KA				; NT::g_protMask
PUBLIC	?g_protOffset@NT@@3KA				; NT::g_protOffset
PUBLIC	?zoa@NT@@3U_OBJECT_ATTRIBUTES@1@A		; NT::zoa
PUBLIC	?PX_SELFMAP@NT@@3_KA				; NT::PX_SELFMAP
PUBLIC	?PTE_BASE_X64@NT@@3_KA				; NT::PTE_BASE_X64
PUBLIC	?PDE_BASE_X64@NT@@3_KA				; NT::PDE_BASE_X64
PUBLIC	?PPE_BASE_X64@NT@@3_KA				; NT::PPE_BASE_X64
PUBLIC	?PXE_BASE_X64@NT@@3_KA				; NT::PXE_BASE_X64
PUBLIC	?g_OsVersion@NT@@3GA				; NT::g_OsVersion
PUBLIC	?g_ControlDevice@NT@@3PEAU_DEVICE_OBJECT@1@EA	; NT::g_ControlDevice
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_PsGetVersion:PROC
EXTRN	__imp_MmIsAddressValid:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_ExAllocatePool:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_PsLookupThreadByThreadId:PROC
EXTRN	__imp_IoGetCurrentProcess:PROC
EXTRN	__imp_ZwOpenThread:PROC
EXTRN	__imp_ZwOpenProcess:PROC
EXTRN	__imp_IoFreeMdl:PROC
EXTRN	__imp_MmUnlockPages:PROC
EXTRN	__imp_KeUnstackDetachProcess:PROC
EXTRN	__imp_ObQueryNameString:PROC
EXTRN	__imp_PsGetProcessId:PROC
EXTRN	__imp_PsGetThreadId:PROC
EXTRN	__imp_PsGetThreadTeb:PROC
EXTRN	__imp_PsGetProcessImageFileName:PROC
EXTRN	__imp__swprintf:PROC
EXTRN	__imp_PsGetThreadProcess:PROC
EXTRN	__imp_ObReferenceObjectByHandle:PROC
EXTRN	IoFileObjectType:QWORD
EXTRN	PsProcessType:QWORD
EXTRN	PsThreadType:QWORD
EXTRN	__imp_KeStackAttachProcess:PROC
EXTRN	__imp_PsInitialSystemProcess:QWORD
EXTRN	__imp_ZwQuerySystemInformation:PROC
EXTRN	__imp_MmMapLockedPagesSpecifyCache:PROC
EXTRN	__imp_MmProbeAndLockPages:PROC
EXTRN	__imp_IoAllocateMdl:PROC
EXTRN	__imp_PsLookupProcessByProcessId:PROC
EXTRN	__imp_ProbeForWrite:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_ProbeForRead:PROC
EXTRN	__imp___C_specific_handler:PROC
?g_protMax@NT@@3KA DD 01H DUP (?)			; NT::g_protMax
?g_protMask@NT@@3KA DD 01H DUP (?)			; NT::g_protMask
?g_protOffset@NT@@3KA DD 01H DUP (?)			; NT::g_protOffset
	ALIGN	8

?PX_SELFMAP@NT@@3_KA DQ 01H DUP (?)			; NT::PX_SELFMAP
?PTE_BASE_X64@NT@@3_KA DQ 01H DUP (?)			; NT::PTE_BASE_X64
?PDE_BASE_X64@NT@@3_KA DQ 01H DUP (?)			; NT::PDE_BASE_X64
?PPE_BASE_X64@NT@@3_KA DQ 01H DUP (?)			; NT::PPE_BASE_X64
?PXE_BASE_X64@NT@@3_KA DQ 01H DUP (?)			; NT::PXE_BASE_X64
?g_OsVersion@NT@@3GA DW 01H DUP (?)			; NT::g_OsVersion
	ALIGN	8

?g_ControlDevice@NT@@3PEAU_DEVICE_OBJECT@1@EA DQ 01H DUP (?) ; NT::g_ControlDevice
_BSS	ENDS
?zoa@NT@@3U_OBJECT_ATTRIBUTES@1@A DD 030H		; NT::zoa
	ORG $+4
	ORG $+40
_DATA	ENDS
;	COMDAT ?__870@?1??FindProtectedBits@NT@@YAXXZ@4QB_WB
CONST	SEGMENT
?__870@?1??FindProtectedBits@NT@@YAXXZ@4QB_WB DB 'P', 00H, 's', 00H, 'I', 00H
	DB	's', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 't', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H ; `NT::FindProtectedBits'::`2'::__870
CONST	ENDS
;	COMDAT ?PsIsProtectedProcess@?1??FindProtectedBits@NT@@YAXXZ@4U_UNICODE_STRING@2@B
CONST	SEGMENT
?PsIsProtectedProcess@?1??FindProtectedBits@NT@@YAXXZ@4U_UNICODE_STRING@2@B DW 028H ; `NT::FindProtectedBits'::`2'::PsIsProtectedProcess
	DW	02aH
	ORG $+4
	DQ	FLAT:?__870@?1??FindProtectedBits@NT@@YAXXZ@4QB_WB
CONST	ENDS
;	COMDAT ?__1117@?1??DriverEntry@@9@4QB_WB
CONST	SEGMENT
?__1117@?1??DriverEntry@@9@4QB_WB DB '\', 00H, 'd', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, '\', 00H, '6', 00H, '9', 00H, '7'
	DB	00H, '6', 00H, '6', 00H, '7', 00H, '8', 00H, '1', 00H, '1', 00H
	DB	'7', 00H, '8', 00H, 'D', 00H, '4', 00H, '2', 00H, '2', 00H, 'c'
	DB	00H, 'A', 00H, '1', 00H, '8', 00H, '3', 00H, '7', 00H, '7', 00H
	DB	'5', 00H, '6', 00H, '1', 00H, '1', 00H, 'A', 00H, '8', 00H, 'E'
	DB	00H, 'E', 00H, '5', 00H, '5', 00H, 00H, 00H	; `DriverEntry'::`2'::__1117
CONST	ENDS
;	COMDAT ?s_fiod@?1??DriverEntry@@9@4U_FAST_IO_DISPATCH@NT@@B
CONST	SEGMENT
?s_fiod@?1??DriverEntry@@9@4U_FAST_IO_DISPATCH@NT@@B DD 0e0H ; `DriverEntry'::`2'::s_fiod
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z
	ORG $+136
CONST	ENDS
;	COMDAT ?DeviceName@?1??DriverEntry@@9@4U_UNICODE_STRING@NT@@B
CONST	SEGMENT
?DeviceName@?1??DriverEntry@@9@4U_UNICODE_STRING@NT@@B DW 050H ; `DriverEntry'::`2'::DeviceName
	DW	052H
	ORG $+4
	DQ	FLAT:?__1117@?1??DriverEntry@@9@4QB_WB
CONST	ENDS
;	COMDAT ??_C@_1M@JGIJAGIL@?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAS@
CONST	SEGMENT
??_C@_1M@JGIJAGIL@?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAS@ DB '%', 00H, 'x', 00H
	DB	' ', 00H, '%', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MCHDAEEC@?$AA?$CF?$AAx?$AA?4?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAp?$AA?5?$AA?$CF?$AAS@
CONST	SEGMENT
??_C@_1BI@MCHDAEEC@?$AA?$CF?$AAx?$AA?4?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAp?$AA?5?$AA?$CF?$AAS@ DB '%'
	DB	00H, 'x', 00H, '.', 00H, '%', 00H, 'x', 00H, ' ', 00H, '%', 00H
	DB	'p', 00H, ' ', 00H, '%', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
PUBLIC	MmGetSystemAddressForMdlSafe
PUBLIC	DriverEntry
PUBLIC	?FoundSelfMapIndex@NT@@YAHXZ			; NT::FoundSelfMapIndex
PUBLIC	?FindProtectedBits@NT@@YAXXZ			; NT::FindProtectedBits
PUBLIC	?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z		; NT::FindProtectedBits
PUBLIC	?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z ; NT::FastIoDeviceControl
PUBLIC	?SetProtectedProcess@NT@@YAJH@Z			; NT::SetProtectedProcess
PUBLIC	?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z ; NT::OpenTreadByCID
PUBLIC	?OpenProcessById@NT@@YAJPEAPEAX0@Z		; NT::OpenProcessById
PUBLIC	?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z		; NT::KQueryHandles
PUBLIC	?KQueryMemory@NT@@YAJPEA_K0@Z			; NT::KQueryMemory
PUBLIC	?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z	; NT::LookupById
PUBLIC	?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z ; NT::OnCreate
PUBLIC	?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z ; NT::OnCloseCleanup
PUBLIC	?DriverUnload@NT@@YAXPEAU_DRIVER_OBJECT@1@@Z	; NT::DriverUnload
PUBLIC	?Read@NT@@YAJPEAX0KPEAK@Z			; NT::Read
PUBLIC	?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z		; NT::findFirstNotValidVA
PUBLIC	?IsAddressValid@NT@@YAH_K@Z			; NT::IsAddressValid
;	COMDAT pdata
pdata	SEGMENT
$pdata$MmGetSystemAddressForMdlSafe DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$MmGetSystemAddressForMdlSafe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN24
	DD	imagerel $LN24+482
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FoundSelfMapIndex@NT@@YAHXZ DD imagerel $LN17
	DD	imagerel $LN17+265
	DD	imagerel $unwind$?FoundSelfMapIndex@NT@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindProtectedBits@NT@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?FindProtectedBits@NT@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z DD imagerel $LN37
	DD	imagerel $LN37+316
	DD	imagerel $unwind$?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+354
	DD	imagerel $unwind$?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetProtectedProcess@NT@@YAJH@Z DD imagerel $LN11
	DD	imagerel $LN11+89
	DD	imagerel $unwind$?SetProtectedProcess@NT@@YAJH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+82
	DD	imagerel $unwind$?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenProcessById@NT@@YAJPEAPEAX0@Z DD imagerel $LN10
	DD	imagerel $LN10+87
	DD	imagerel $unwind$?OpenProcessById@NT@@YAJPEAPEAX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z DD imagerel $LN67
	DD	imagerel $LN67+1319
	DD	imagerel $unwind$?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?KQueryMemory@NT@@YAJPEA_K0@Z DD imagerel $LN12
	DD	imagerel $LN12+146
	DD	imagerel $unwind$?KQueryMemory@NT@@YAJPEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z DD imagerel $LN12
	DD	imagerel $LN12+115
	DD	imagerel $unwind$?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+26
	DD	imagerel $unwind$?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+26
	DD	imagerel $unwind$?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Read@NT@@YAJPEAX0KPEAK@Z DD imagerel $LN32
	DD	imagerel $LN32+395
	DD	imagerel $unwind$?Read@NT@@YAJPEAX0KPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z DD imagerel $LN50
	DD	imagerel $LN50+602
	DD	imagerel $unwind$?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z DD 0a1901H
	DD	0d3419H
	DD	0f0153219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Read@NT@@YAJPEAX0KPEAK@Z DD 081409H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN32+70
	DD	imagerel $LN32+356
	DD	01H
	DD	imagerel $LN32+356
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z DD 060f09H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+41
	DD	imagerel $LN12+61
	DD	01H
	DD	imagerel $LN12+92
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?KQueryMemory@NT@@YAJPEA_K0@Z DD 040a09H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+33
	DD	imagerel $LN12+135
	DD	01H
	DD	imagerel $LN12+135
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z DD 0b1a09H
	DD	023641aH
	DD	022341aH
	DD	01c011aH
	DD	0e011f013H
	DD	0c00dd00fH
	DD	0700bH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN67+35
	DD	imagerel $LN67+1286
	DD	01H
	DD	imagerel $LN67+1290
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenProcessById@NT@@YAJPEAPEAX0@Z DD 040a09H
	DD	08340aH
	DD	07006520aH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN10+16
	DD	imagerel $LN10+76
	DD	01H
	DD	imagerel $LN10+76
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z DD 040a09H
	DD	08340aH
	DD	07006520aH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN10+16
	DD	imagerel $LN10+71
	DD	01H
	DD	imagerel $LN10+71
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetProtectedProcess@NT@@YAJH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z DD 0a1909H
	DD	0d7419H
	DD	0c6419H
	DD	0b3419H
	DD	0f0155219H
	DD	0c011e013H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN37+54
	DD	imagerel $LN37+108
	DD	01H
	DD	imagerel $LN37+290
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindProtectedBits@NT@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FoundSelfMapIndex@NT@@YAHXZ DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 081201H
	DD	0f3412H
	DD	0e00e7212H
	DD	0700ac00cH
	DD	050086009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MmGetSystemAddressForMdlSafe DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?IsAddressValid@NT@@YAH_K@Z
_TEXT	SEGMENT
p$ = 8
?IsAddressValid@NT@@YAH_K@Z PROC			; NT::IsAddressValid, COMDAT

; 25   : 	_PTE* pte = PXE_X64_L(p);
; 26   : 
; 27   : 	if (pte->Valid)

	mov	rax, QWORD PTR ?PXE_BASE_X64@NT@@3_KA	; NT::PXE_BASE_X64
	mov	rdx, rcx
	shr	rdx, 36					; 00000024H
	mov	r8d, 1
	and	edx, 4088				; 00000ff8H
	mov	r9, rcx
	test	BYTE PTR [rdx+rax], r8b
	je	SHORT $LN4@IsAddressV

; 28   : 	{
; 29   : 		pte = PPE_X64_L(p);
; 30   : 
; 31   : 		if (pte->Valid)

	mov	rax, QWORD PTR ?PPE_BASE_X64@NT@@3_KA	; NT::PPE_BASE_X64
	mov	rdx, rcx
	shr	rdx, 27
	and	edx, 2097144				; 001ffff8H
	test	BYTE PTR [rdx+rax], r8b
	je	SHORT $LN4@IsAddressV

; 32   : 		{
; 33   : 			pte = PDE_X64_L(p);

	mov	rdx, rcx

; 34   : 
; 35   : 			if (pte->Valid)

	mov	rcx, QWORD PTR ?PDE_BASE_X64@NT@@3_KA	; NT::PDE_BASE_X64
	shr	rdx, 18
	and	edx, 1073741816				; 3ffffff8H
	test	BYTE PTR [rdx+rcx], r8b
	je	SHORT $LN4@IsAddressV

; 36   : 			{
; 37   : 				if (pte->LargePage)

	test	BYTE PTR [rdx+rcx], 128			; 00000080H
	je	SHORT $LN5@IsAddressV
$LN9@IsAddressV:

; 50   : }

	mov	eax, r8d
	ret	0
$LN5@IsAddressV:

; 38   : 				{
; 39   : 					return TRUE;
; 40   : 				}
; 41   : 
; 42   : 				pte = PTE_X64_L(p);

	shr	r9, 9
	mov	rax, 549755813880			; 0000007ffffffff8H
	and	r9, rax

; 43   : 
; 44   : 				return pte->Valid || pte->Prototype || (pte->Protection && pte->Protection < MM_NOCACHE);

	mov	rax, QWORD PTR ?PTE_BASE_X64@NT@@3_KA	; NT::PTE_BASE_X64
	mov	rcx, QWORD PTR [r9+rax]
	test	rcx, 1025				; 00000401H
	jne	SHORT $LN9@IsAddressV
	and	ecx, 992				; 000003e0H
	sub	rcx, r8
	cmp	rcx, 254				; 000000feH
	jbe	SHORT $LN9@IsAddressV
	xor	r8d, r8d
	jmp	SHORT $LN9@IsAddressV
$LN4@IsAddressV:

; 45   : 			}
; 46   : 		}
; 47   : 	}
; 48   : 
; 49   : 	return FALSE;

	xor	eax, eax

; 50   : }

	ret	0
?IsAddressValid@NT@@YAH_K@Z ENDP			; NT::IsAddressValid
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z
_TEXT	SEGMENT
pte$1$ = 0
tv709 = 8
tv707 = 16
tv708 = 24
tv710 = 96
p$ = 96
d$ = 104
q$ = 112
tv711 = 120
?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z PROC		; NT::findFirstNotValidVA, COMDAT

; 59   : {

$LN50:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 60   : 	DWORD i = (p >> PXI_SHIFT) & PXI_MASK;
; 61   : 	DWORD j = (p >> PPI_SHIFT) & PPI_MASK;
; 62   : 	DWORD k = (p >> PDI_SHIFT) & PDI_MASK_AMD64;
; 63   : 	DWORD l = (p >> PTI_SHIFT) & PTI_MASK_AMD64;
; 64   : 
; 65   : 	ULONG_PTR X = 0, Y = 0;
; 66   : 
; 67   : 	BOOL bValid = FALSE;
; 68   : 
; 69   : 	_PTE* pte = PXE(i);

	mov	rax, QWORD PTR ?PX_SELFMAP@NT@@3_KA	; NT::PX_SELFMAP
	mov	rbx, rcx
	mov	rdi, rcx
	shr	rbx, 39					; 00000027H
	mov	r9, rcx
	movsxd	r10, edx
	mov	rsi, rcx
	shr	rdi, 12
	mov	r15, rax
	shr	r9, 30
	mov	r12, rax
	shl	r15, 21
	mov	r13, rax
	shl	r12, 39					; 00000027H
	shl	r13, 30
	mov	r14d, 511				; 000001ffH
	shl	rax, 12
	and	ebx, r14d
	add	rax, r15
	shr	rsi, 21
	mov	rcx, -281474976710656			; ffff000000000000H
	mov	QWORD PTR tv710[rsp], r12
	and	edi, r14d
	mov	QWORD PTR tv709[rsp], r13
	xor	ebp, ebp
	mov	QWORD PTR tv708[rsp], r15
	lea	rdx, QWORD PTR [rax+rbx*8]
	xor	r8d, r8d
	add	rdx, r13
	xor	r11d, r11d
	add	rcx, rdx
	add	rcx, r12
	mov	QWORD PTR pte$1$[rsp], rcx
$LL4@findFirstN:

; 70   : 
; 71   : 	do 
; 72   : 	{
; 73   : 		if (!pte->Valid)

	test	BYTE PTR [rcx], 1
	je	$leave$51

; 74   : 		{
; 75   : 			goto leave;
; 76   : 		}
; 77   : 
; 78   : 		_PTE* pte = PPE(i, j &= PPI_MASK);

	and	r9d, r14d
	mov	eax, ebx
	shl	rax, 12
	add	rax, r15
	mov	r14d, ebx
	mov	r15, -281474976710656			; ffff000000000000H
	mov	QWORD PTR tv711[rsp], r14
	lea	rcx, QWORD PTR [rax+r9*8]
	add	rcx, r13
	add	r15, rcx
	add	r15, r12
$LL7@findFirstN:

; 79   : 
; 80   : 		do 
; 81   : 		{
; 82   : 			if (!pte->Valid)

	test	BYTE PTR [r15], 1
	je	$leave$51

; 83   : 			{
; 84   : 				goto leave;
; 85   : 			}
; 86   : 
; 87   : 			_PTE* pte = PDE(i, j, k &= PDI_MASK_AMD64);

	mov	rcx, r14
	mov	r8d, r9d
	add	r14, 33553920				; 01fffe00H
	shl	rcx, 21
	and	esi, 511				; 000001ffH
	shl	r14, 9
	mov	eax, r9d
	add	r14, r8
	shl	rax, 12

; 130  : 
; 131  : 			} while (pte += d, (k += d) < PDE_PER_PAGE);

	mov	edx, 512				; 00000200H
	add	rax, r13
	mov	QWORD PTR tv707[rsp], r8
	mov	r13, -281474976710656			; ffff000000000000H
	lea	rax, QWORD PTR [rax+rsi*8]
	add	rcx, rax
	add	r13, rcx
	add	r13, r12
	shl	r14, 9
$LL48@findFirstN:

; 88   : 
; 89   : 			do 
; 90   : 			{
; 91   : 				Y = LA(i, j, k, 0);

	lea	r12, QWORD PTR [r14+rsi]
	mov	ecx, esi
	mov	r8, r12
	mov	rax, r10
	shl	r8, 21

; 92   : 
; 93   : 				if (!pte->Valid)

	test	BYTE PTR [r13], 1
	je	$leave$51

; 94   : 				{
; 95   : 					goto leave;
; 96   : 				}
; 97   : 
; 98   : 				if (pte->LargePage)

	test	BYTE PTR [r13], 128			; 00000080H
	je	SHORT $LN20@findFirstN

; 99   : 				{
; 100  : 					X = Y;

	mov	rbp, r8

; 101  : 					bValid = TRUE;
; 102  : 					continue;

	jmp	$LN8@findFirstN
$LN20@findFirstN:

; 103  : 				}
; 104  : 
; 105  : 				_PTE* pte = PTE(i, j, k, l &= PTI_MASK_AMD64);

	mov	rdx, QWORD PTR tv707[rsp]
	and	edi, 511				; 000001ffH
	mov	rax, QWORD PTR tv711[rsp]
	shl	rcx, 12
	shl	rdx, 21
	add	rdx, QWORD PTR tv710[rsp]
	shl	rax, 30
	lea	rcx, QWORD PTR [rcx+rdi*8]
	add	rdx, rcx
	mov	rcx, -281474976710656			; ffff000000000000H
	add	rcx, rax
	add	rcx, rdx
	mov	edx, 512				; 00000200H
	shl	r12, 9
$LL13@findFirstN:

; 106  : 
; 107  : 				do 
; 108  : 				{
; 109  : 					Y = LA(i, j, k, l);
; 110  : 
; 111  : 					if (pte->Valid)

	mov	rax, QWORD PTR [rcx]
	mov	r8d, edi
	add	r8, r12
	shl	r8, 12
	test	al, 1
	jne	SHORT $LN11@findFirstN

; 112  : 					{
; 113  : 						X = Y;
; 114  : 						bValid = TRUE;
; 115  : 					}
; 116  : 					else
; 117  : 					{
; 118  : 						if (pte->Prototype || (pte->Protection && pte->Protection < MM_NOCACHE))

	bt	rax, 10
	jb	SHORT $LN11@findFirstN
	and	eax, 992				; 000003e0H
	dec	rax
	cmp	rax, 254				; 000000feH
	ja	SHORT $leave$51
$LN11@findFirstN:

; 119  : 						{
; 120  : 							X = Y;
; 121  : 							bValid = TRUE;
; 122  : 						}
; 123  : 						else
; 124  : 						{
; 125  : 							goto leave;
; 126  : 						}
; 127  : 					}
; 128  : 
; 129  : 				} while (pte += d, (l += d) < PTE_PER_PAGE);

	add	edi, r10d
	lea	rcx, QWORD PTR [rcx+r10*8]
	mov	rax, r10
	mov	rbp, r8
	mov	r11d, 1
	cmp	edi, edx
	jb	SHORT $LL13@findFirstN
$LN8@findFirstN:

; 130  : 
; 131  : 			} while (pte += d, (k += d) < PDE_PER_PAGE);

	shl	rax, 3
	add	esi, r10d
	add	r13, rax
	mov	r8, rbp
	mov	r11d, 1
	cmp	esi, edx
	jb	$LL48@findFirstN

; 132  : 
; 133  : 		} while (pte += d, (j += d) < PPE_PER_PAGE);

	mov	r14, QWORD PTR tv711[rsp]
	add	r15, rax
	mov	r12, QWORD PTR tv710[rsp]
	add	r9d, r10d
	mov	r13, QWORD PTR tv709[rsp]
	cmp	r9d, edx
	jb	$LL7@findFirstN

; 134  : 
; 135  : 	} while (pte += d, (i += d) < PXE_PER_PAGE);

	mov	rcx, QWORD PTR pte$1$[rsp]
	add	ebx, r10d
	mov	r15, QWORD PTR tv708[rsp]
	add	rcx, rax
	mov	QWORD PTR pte$1$[rsp], rcx
	mov	r14d, 511				; 000001ffH
	cmp	ebx, edx
	jb	$LL4@findFirstN
$leave$51:

; 136  : 
; 137  : leave:
; 138  : 
; 139  : 	if (bValid)

	test	r11d, r11d
	je	SHORT $LN27@findFirstN

; 140  : 	{
; 141  : 		q = d < 0 ? X : Y;

	mov	rcx, QWORD PTR q$[rsp]
	test	r10d, r10d

; 142  : 		return TRUE;

	mov	eax, 1
	cmovs	r8, rbp
	mov	QWORD PTR [rcx], r8
	jmp	SHORT $LN1@findFirstN
$LN27@findFirstN:

; 143  : 	}
; 144  : 
; 145  : 	return FALSE;

	xor	eax, eax
$LN1@findFirstN:

; 146  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z ENDP		; NT::findFirstNotValidVA
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?Read@NT@@YAJPEAX0KPEAK@Z
_TEXT	SEGMENT
cbCopyed$ = 32
status$ = 36
Buffer$1$ = 40
Address$1 = 48
InputBuffer$ = 128
Buffer$ = 136
Length$ = 144
pcbCopyed$ = 152
?Read@NT@@YAJPEAX0KPEAK@Z PROC				; NT::Read, COMDAT

; 361  : {

$LN32:
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r15, r9
	mov	r12d, r8d
	mov	QWORD PTR Buffer$1$[rsp], rdx
	mov	r14, rcx

; 362  : 	if (!PX_SELFMAP)

	xor	edi, edi
	cmp	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rdi	; NT::PX_SELFMAP
	jne	SHORT $LN5@Read

; 363  : 	{
; 364  : 		return STATUS_NOT_FOUND;

	mov	eax, -1073741275			; ffffffffc0000225H
	jmp	$LN1@Read
$LN5@Read:

; 365  : 	}
; 366  : 
; 367  : 	DWORD cbCopyed = 0;

	mov	DWORD PTR cbCopyed$[rsp], edi

; 368  : 	NTSTATUS status = STATUS_SUCCESS;

	mov	esi, edi

; 369  : 
; 370  : 	if (Length) __try

	test	r8d, r8d
	je	$LN15@Read

; 371  : 	{
; 372  : 		ProbeForRead(InputBuffer, sizeof(PVOID), __alignof(PVOID));

	mov	edx, 8
	mov	r8d, edx
	call	QWORD PTR __imp_ProbeForRead

; 373  : 
; 374  : 		ULONG_PTR Address = *(PULONG_PTR)InputBuffer;

	mov	r14, QWORD PTR [r14]
	mov	QWORD PTR Address$1[rsp], r14

; 375  : 		
; 376  : 		DWORD cb = (DWORD)(((Address + PAGE_SIZE) & ~(PAGE_SIZE - 1)) - Address);

	lea	r13d, DWORD PTR [r14+4096]
	and	r13d, -4096				; fffff000H
	sub	r13d, r14d
$LL4@Read:

; 377  : 
; 378  : 		do 
; 379  : 		{
; 380  : 			if (Length < cb) cb = Length;

	cmp	r12d, r13d
	cmovb	r13d, r12d

; 25   : 	_PTE* pte = PXE_X64_L(p);

	mov	rax, r14
	shr	rax, 36					; 00000024H
	and	eax, 4088				; 00000ff8H
	add	rax, QWORD PTR ?PXE_BASE_X64@NT@@3_KA	; NT::PXE_BASE_X64

; 26   : 
; 27   : 	if (pte->Valid)

	test	BYTE PTR [rax], 1
	je	$LN23@Read

; 28   : 	{
; 29   : 		pte = PPE_X64_L(p);

	mov	rax, r14
	shr	rax, 27
	and	eax, 2097144				; 001ffff8H
	add	rax, QWORD PTR ?PPE_BASE_X64@NT@@3_KA	; NT::PPE_BASE_X64

; 30   : 
; 31   : 		if (pte->Valid)

	test	BYTE PTR [rax], 1
	je	$LN23@Read

; 32   : 		{
; 33   : 			pte = PDE_X64_L(p);

	mov	rax, r14
	shr	rax, 18
	and	eax, 1073741816				; 3ffffff8H
	add	rax, QWORD PTR ?PDE_BASE_X64@NT@@3_KA	; NT::PDE_BASE_X64

; 34   : 
; 35   : 			if (pte->Valid)

	test	BYTE PTR [rax], 1
	je	$LN23@Read

; 36   : 			{
; 37   : 				if (pte->LargePage)

	test	BYTE PTR [rax], 128			; 00000080H
	jne	SHORT $LN29@Read

; 38   : 				{
; 39   : 					return TRUE;
; 40   : 				}
; 41   : 
; 42   : 				pte = PTE_X64_L(p);

	mov	rax, r14
	shr	rax, 9
	mov	rcx, 549755813880			; 0000007ffffffff8H
	and	rax, rcx
	add	rax, QWORD PTR ?PTE_BASE_X64@NT@@3_KA	; NT::PTE_BASE_X64
	mov	rcx, QWORD PTR [rax]
	test	rcx, 1025				; 00000401H

; 43   : 
; 44   : 				return pte->Valid || pte->Prototype || (pte->Protection && pte->Protection < MM_NOCACHE);

	jne	SHORT $LN29@Read
	and	ecx, 992				; 000003e0H
	dec	rcx
	cmp	rcx, 254				; 000000feH
	ja	SHORT $LN23@Read
$LN29@Read:

; 385  : 				break;
; 386  : 			}
; 387  : 
; 388  : 			memcpy(Buffer, (PVOID)Address, cb);

	mov	ebx, r13d
	mov	r8d, r13d
	mov	rdx, r14
	mov	rcx, QWORD PTR Buffer$1$[rsp]
	call	memcpy

; 389  : 
; 390  : 			Buffer = RtlOffsetToPointer(Buffer, cb);

	mov	rax, QWORD PTR Buffer$1$[rsp]
	add	rax, rbx
	mov	QWORD PTR Buffer$1$[rsp], rax
	mov	QWORD PTR Buffer$[rsp], rax

; 391  : 			Address += cb;

	lea	rax, QWORD PTR [r14+r13]
	mov	r14, rax
	mov	QWORD PTR Address$1[rsp], rax

; 392  : 			cbCopyed += cb;

	add	edi, r13d
	mov	DWORD PTR cbCopyed$[rsp], edi

; 393  : 			Length -= cb;

	sub	r12d, r13d
	mov	DWORD PTR Length$[rsp], r12d

; 394  : 			cb = PAGE_SIZE;

	mov	r13d, 4096				; 00001000H

; 395  : 
; 396  : 		} while (Length);

	je	SHORT $LN3@Read
	jmp	$LL4@Read
$LN23@Read:

; 381  : 
; 382  : 			if (!IsAddressValid(Address))
; 383  : 			{
; 384  : 				status = STATUS_ACCESS_VIOLATION;

	mov	esi, -1073741819			; ffffffffc0000005H
	mov	DWORD PTR status$[rsp], esi
$LN3@Read:

; 397  : 	}

	jmp	SHORT $LN15@Read
$LN13@Read:

; 398  : 	__except(EXCEPTION_EXECUTE_HANDLER)

	mov	esi, eax

; 399  : 	{
; 400  : 		status = GetExceptionCode();

	mov	DWORD PTR status$[rsp], eax

; 397  : 	}

	mov	r15, QWORD PTR pcbCopyed$[rsp]
	mov	edi, DWORD PTR cbCopyed$[rsp]
$LN15@Read:

; 401  : 	}
; 402  : 	
; 403  : 	*pcbCopyed = cbCopyed;

	mov	DWORD PTR [r15], edi

; 404  : 
; 405  : 	return status;

	mov	eax, esi
$LN1@Read:

; 406  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?Read@NT@@YAJPEAX0KPEAK@Z ENDP				; NT::Read
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?DriverUnload@NT@@YAXPEAU_DRIVER_OBJECT@1@@Z
_TEXT	SEGMENT
__formal$ = 8
?DriverUnload@NT@@YAXPEAU_DRIVER_OBJECT@1@@Z PROC	; NT::DriverUnload, COMDAT

; 410  : 	IoDeleteDevice(g_ControlDevice);

	mov	rcx, QWORD PTR ?g_ControlDevice@NT@@3PEAU_DEVICE_OBJECT@1@EA ; NT::g_ControlDevice
	rex_jmp	QWORD PTR __imp_IoDeleteDevice
?DriverUnload@NT@@YAXPEAU_DRIVER_OBJECT@1@@Z ENDP	; NT::DriverUnload
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z
_TEXT	SEGMENT
__formal$ = 48
Irp$ = 56
?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z PROC ; NT::OnCloseCleanup, COMDAT

; 414  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 415  : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	and	DWORD PTR [rdx+48], 0

; 416  : 	IofCompleteRequest(Irp, IO_NO_INCREMENT);

	mov	rcx, rdx
	xor	edx, edx
	call	QWORD PTR __imp_IofCompleteRequest

; 417  : 	return STATUS_SUCCESS;

	xor	eax, eax

; 418  : }

	add	rsp, 40					; 00000028H
	ret	0
?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z ENDP ; NT::OnCloseCleanup
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z PROC ; NT::OnCreate, COMDAT

; 421  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 415  : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	and	DWORD PTR [rdx+48], 0

; 416  : 	IofCompleteRequest(Irp, IO_NO_INCREMENT);

	mov	rcx, rdx
	xor	edx, edx
	call	QWORD PTR __imp_IofCompleteRequest

; 422  : 	return OnCloseCleanup(DeviceObject, Irp);

	xor	eax, eax

; 423  : }

	add	rsp, 40					; 00000028H
	ret	0
?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z ENDP ; NT::OnCreate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z
_TEXT	SEGMENT
pvObject$1 = 32
Id$2 = 40
ppvObject$ = 64
fn$ = 72
InputBuffer$ = 80
InputBufferLength$ = 88
OutputBufferLength$ = 96
?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z PROC		; NT::LookupById, COMDAT

; 434  : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 435  : 	if (!OutputBufferLength && InputBufferLength == sizeof(HANDLE))

	cmp	DWORD PTR OutputBufferLength$[rsp], 0
	jne	SHORT $LN2@LookupById
	mov	edx, 8
	cmp	r9d, edx
	jne	SHORT $LN2@LookupById

; 436  : 	{
; 437  : 		HANDLE Id;
; 438  : 
; 439  : 		__try
; 440  : 		{
; 441  : 			ProbeForRead(InputBuffer, sizeof(HANDLE), __alignof(HANDLE));

	mov	r8d, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_ProbeForRead

; 442  : 			Id = *(HANDLE*)InputBuffer;

	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR Id$2[rsp], rcx

; 447  : 		}
; 448  : 
; 449  : 		PVOID pvObject;
; 450  : 		NTSTATUS status = fn(Id, &pvObject);

	lea	rdx, QWORD PTR pvObject$1[rsp]
	call	rsi
	mov	ebx, eax

; 451  : 		
; 452  : 		if (0 <= status)

	test	eax, eax
	js	SHORT $LN4@LookupById

; 453  : 		{
; 454  : 			*ppvObject = pvObject;

	mov	rcx, QWORD PTR pvObject$1[rsp]
	mov	QWORD PTR [rdi], rcx

; 455  : 			ObfDereferenceObject(pvObject);

	call	QWORD PTR __imp_ObfDereferenceObject
$LN4@LookupById:

; 456  : 		}
; 457  : 
; 458  : 		return status;

	mov	eax, ebx
	jmp	SHORT $LN1@LookupById
$LN8@LookupById:

; 443  : 		}
; 444  : 		__except(EXCEPTION_EXECUTE_HANDLER)
; 445  : 		{
; 446  : 			return GetExceptionCode();

	jmp	SHORT $LN1@LookupById
$LN2@LookupById:

; 459  : 	}
; 460  : 
; 461  : 	return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
$LN1@LookupById:

; 462  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z ENDP		; NT::LookupById
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?KQueryMemory@NT@@YAJPEA_K0@Z
_TEXT	SEGMENT
pp$ = 48
pq$ = 56
a$1 = 64
b$2 = 72
?KQueryMemory@NT@@YAJPEA_K0@Z PROC			; NT::KQueryMemory, COMDAT

; 465  : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 466  : 	if (!PX_SELFMAP)

	cmp	QWORD PTR ?PX_SELFMAP@NT@@3_KA, 0	; NT::PX_SELFMAP
	jne	SHORT $LN2@KQueryMemo

; 467  : 	{
; 468  : 		return STATUS_NOT_FOUND;

	mov	eax, -1073741275			; ffffffffc0000225H
	jmp	SHORT $LN10@KQueryMemo
$LN2@KQueryMemo:

; 469  : 	}
; 470  : 	__try
; 471  : 	{
; 472  : 		ProbeForRead(pp, sizeof(ULONG_PTR), __alignof(ULONG_PTR));

	mov	edx, 8
	mov	r8d, edx
	call	QWORD PTR __imp_ProbeForRead

; 473  : 		ULONG_PTR p = *pp, a, b;
; 474  : 		if (findFirstNotValidVA(p, -1, a) && findFirstNotValidVA(p, +1, b))

	lea	r8, QWORD PTR a$1[rsp]
	or	edx, -1
	mov	rcx, QWORD PTR [rdi]
	call	?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z	; NT::findFirstNotValidVA
	test	eax, eax
	je	SHORT $LN4@KQueryMemo
	lea	r8, QWORD PTR b$2[rsp]
	mov	edx, 1
	mov	rcx, QWORD PTR [rdi]
	call	?findFirstNotValidVA@NT@@YAH_KHAEA_K@Z	; NT::findFirstNotValidVA
	test	eax, eax
	je	SHORT $LN4@KQueryMemo

; 475  : 		{
; 476  : 			ProbeForWrite(pq, 2*sizeof(ULONG_PTR), __alignof(ULONG_PTR));

	mov	edx, 16
	lea	r8d, QWORD PTR [rdx-8]
	mov	rcx, rbx
	call	QWORD PTR __imp_ProbeForWrite

; 477  : 			pq[0] = a, pq[1] = b;

	mov	rax, QWORD PTR a$1[rsp]
	mov	QWORD PTR [rbx], rax
	mov	rax, QWORD PTR b$2[rsp]
	mov	QWORD PTR [rbx+8], rax

; 478  : 			return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN10@KQueryMemo
$LN4@KQueryMemo:

; 479  : 		}
; 480  : 
; 481  : 		return STATUS_MEMORY_NOT_ALLOCATED;

	mov	eax, -1073741664			; ffffffffc00000a0H
	jmp	SHORT $LN10@KQueryMemo
$LN8@KQueryMemo:
$LN10@KQueryMemo:

; 482  : 	}
; 483  : 	__except(EXCEPTION_EXECUTE_HANDLER)
; 484  : 	{
; 485  : 		return GetExceptionCode();
; 486  : 	}
; 487  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?KQueryMemory@NT@@YAJPEA_K0@Z ENDP			; NT::KQueryMemory
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
; File c:\inc\km\wdm.h
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z
_TEXT	SEGMENT
rcb$1 = 48
ProcessIndex$1$ = 52
status$ = 56
Object$2 = 64
n$3 = 72
tv628 = 80
pshti$4 = 80
sz$5 = 88
poni$6 = 96
tv662 = 104
Handles$7 = 112
pshti$1$ = 120
Mdl$1$ = 128
Process$8 = 136
p$9 = 144
NumberOfHandles$10 = 152
HandleValue$11 = 160
as$12 = 168
pfqh$ = 272
OutputBuffer$ = 280
OutputBufferLength$ = 288
ThreadIndex$1$ = 296
?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z PROC		; NT::KQueryHandles, COMDAT

; 492  : {

$LN67:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	r15d, r8d
	mov	r14, rdx
	mov	rbx, rcx

; 493  : 	NTSTATUS status;
; 494  : 
; 495  : 	__try
; 496  : 	{
; 497  : 		ProbeForRead(pfqh, sizeof(HANDLE), __alignof(HANDLE));

	mov	edx, 8
	mov	r8d, edx
	call	QWORD PTR __imp_ProbeForRead

; 498  : 		ULONG_PTR ProcessId = pfqh->ProcessId;

	mov	r13, QWORD PTR [rbx]

; 499  : 		UCHAR ThreadIndex = pfqh->ThreadIndex, ProcessIndex = pfqh->ProcessIndex, FileIndex = pfqh->FileIndex;

	mov	al, BYTE PTR [rbx+8]
	mov	BYTE PTR ThreadIndex$1$[rsp], al
	mov	al, BYTE PTR [rbx+9]
	mov	BYTE PTR ProcessIndex$1$[rsp], al

; 500  : 
; 501  : 		if (g_OsVersion >= _WIN32_WINNT_WS03)

	movzx	eax, BYTE PTR [rbx+10]
	mov	edx, 255				; 000000ffH
	mov	ecx, 1282				; 00000502H
	cmp	WORD PTR ?g_OsVersion@NT@@3GA, cx	; NT::g_OsVersion
	cmovae	eax, edx
	mov	DWORD PTR tv662[rsp], eax

; 502  : 		{
; 503  : 			FileIndex = MAXUCHAR;
; 504  : 		}
; 505  : 
; 506  : 		PEPROCESS Process;
; 507  : 		if (0 <= (status = PsLookupProcessByProcessId((HANDLE)ProcessId, &Process)))

	lea	rdx, QWORD PTR Process$8[rsp]
	mov	rcx, r13
	call	QWORD PTR __imp_PsLookupProcessByProcessId
	mov	ebx, eax
	mov	DWORD PTR status$[rsp], eax
	xor	r12d, r12d
	test	eax, eax
	js	$LN12@KQueryHand

; 508  : 		{
; 509  : 			status = STATUS_INSUFFICIENT_RESOURCES;

	mov	ebx, -1073741670			; ffffffffc000009aH
	mov	DWORD PTR status$[rsp], ebx

; 510  : 
; 511  : 			if (PMDL Mdl = IoAllocateMdl(OutputBuffer, OutputBufferLength, FALSE, FALSE, 0))

	mov	QWORD PTR [rsp+32], r12
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, r15d
	mov	rcx, r14
	call	QWORD PTR __imp_IoAllocateMdl
	mov	rdi, rax
	mov	QWORD PTR Mdl$1$[rsp], rax
	test	rax, rax
	je	$LN13@KQueryHand

; 512  : 			{
; 513  : 				MmProbeAndLockPages(Mdl, KernelMode, IoModifyAccess);

	xor	edx, edx
	lea	r8d, QWORD PTR [r12+2]
	mov	rcx, rax
	call	QWORD PTR __imp_MmProbeAndLockPages
; File c:\inc\km\wdm.h

; 27732:     if (Mdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL)) {

	test	BYTE PTR [rdi+10], 5
	je	SHORT $LN46@KQueryHand

; 27733:         return Mdl->MappedSystemVa;

	mov	rsi, QWORD PTR [rdi+24]
	mov	QWORD PTR pshti$1$[rsp], rsi
	mov	QWORD PTR pshti$4[rsp], rsi
	jmp	SHORT $LN47@KQueryHand
$LN46@KQueryHand:

; 27734:     } else {
; 27735:         return MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmCached,

	mov	DWORD PTR [rsp+40], r12d
	mov	DWORD PTR [rsp+32], r12d
	xor	r9d, r9d
	xor	edx, edx
	lea	r8d, QWORD PTR [r9+1]
	mov	rcx, rdi
	call	QWORD PTR __imp_MmMapLockedPagesSpecifyCache
	mov	rsi, rax
	mov	QWORD PTR pshti$1$[rsp], rax
	mov	QWORD PTR pshti$4[rsp], rax
$LN47@KQueryHand:
; File o:\vc\tkn\tkn.cpp

; 514  : 				if (PSYSTEM_HANDLE_INFORMATION_EX pshti = (PSYSTEM_HANDLE_INFORMATION_EX)MmGetSystemAddressForMdlSafe(Mdl, LowPagePriority))

	test	rsi, rsi
	je	$LN36@KQueryHand

; 515  : 				{
; 516  : 					DWORD rcb;
; 517  : 					if (0 <= (status = ZwQuerySystemInformation(SystemExtendedHandleInformation, OutputBuffer, OutputBufferLength, &rcb)))

	lea	r9, QWORD PTR rcb$1[rsp]
	mov	r8d, r15d
	mov	rdx, r14
	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_ZwQuerySystemInformation
	mov	ebx, eax
	mov	DWORD PTR status$[rsp], eax
	xor	r9d, r9d
	test	eax, eax
	js	$LN36@KQueryHand

; 518  : 					{
; 519  : 						if (ULONG_PTR NumberOfHandles = pshti->NumberOfHandles)

	mov	rcx, QWORD PTR [rsi]
	mov	QWORD PTR NumberOfHandles$10[rsp], rcx
	test	rcx, rcx
	je	$LN36@KQueryHand

; 520  : 						{
; 521  : 							PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles = pshti->Handles, p = Handles;

	lea	r12, QWORD PTR [rsi+16]
	mov	rax, r12
	mov	QWORD PTR Handles$7[rsp], rax
	mov	rbx, r12
	mov	QWORD PTR p$9[rsp], rax

; 522  : 							DWORD n = 0;

	mov	r14d, r9d
	mov	DWORD PTR n$3[rsp], r9d
$LL4@KQueryHand:

; 523  : 							do 
; 524  : 							{
; 525  : 								if (Handles->UniqueProcessId == ProcessId)

	cmp	QWORD PTR [rax+8], r13
	jne	SHORT $LN2@KQueryHand

; 526  : 								{
; 527  : 									Handles->CreatorBackTraceIndex = 0;

	mov	WORD PTR [rax+28], r9w

; 528  : 									Handles->Reserved = 0;

	mov	DWORD PTR [rax+36], r9d

; 529  : 									*p++ = *Handles;

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rbx+16], xmm1
	movsd	xmm0, QWORD PTR [rax+32]
	movsd	QWORD PTR [rbx+32], xmm0
	add	rbx, 40					; 00000028H
	mov	QWORD PTR p$9[rsp], rbx

; 530  : 									n++;

	inc	r14d
	mov	DWORD PTR n$3[rsp], r14d
$LN2@KQueryHand:

; 531  : 								}
; 532  : 							} while (Handles++, --NumberOfHandles);

	add	rax, 40					; 00000028H
	mov	QWORD PTR Handles$7[rsp], rax
	sub	rcx, 1
	mov	QWORD PTR NumberOfHandles$10[rsp], rcx
	jne	SHORT $LL4@KQueryHand

; 533  : 
; 534  : 							if ((pshti->NumberOfHandles = n) && (OutputBufferLength -= RtlPointerToOffset(pshti, p)))

	mov	eax, r14d
	mov	QWORD PTR [rsi], rax
	test	r14d, r14d
	je	$LN60@KQueryHand
	mov	eax, esi
	sub	eax, ebx
	add	r15d, eax
	mov	DWORD PTR OutputBufferLength$[rsp], r15d
	je	$LN60@KQueryHand

; 535  : 							{
; 536  : 								POBJECT_NAME_INFORMATION poni = (POBJECT_NAME_INFORMATION)p;

	mov	QWORD PTR poni$6[rsp], rbx

; 537  : 								PWSTR sz = (PWSTR)p;

	mov	r13, rbx
	mov	QWORD PTR sz$5[rsp], rbx

; 538  : 
; 539  : 								Handles = pshti->Handles;

	mov	QWORD PTR Handles$7[rsp], r12

; 540  : 								BOOL bKernel = Process == PsInitialSystemProcess;

	mov	rax, QWORD PTR __imp_PsInitialSystemProcess
	mov	edx, r9d
	mov	rcx, QWORD PTR Process$8[rsp]
	cmp	rcx, QWORD PTR [rax]
	sete	dl
	mov	DWORD PTR tv628[rsp], edx

; 541  : 								//if (bKernel) DbgBreak();
; 542  : 								KAPC_STATE as;
; 543  : 								if (!bKernel) KeStackAttachProcess(Process, &as);

	je	SHORT $LN52@KQueryHand
	lea	rdx, QWORD PTR as$12[rsp]
	call	QWORD PTR __imp_KeStackAttachProcess
	mov	edx, DWORD PTR tv628[rsp]
	xor	r9d, r9d
$LN52@KQueryHand:
	movzx	eax, BYTE PTR ThreadIndex$1$[rsp]
$LL7@KQueryHand:

; 544  : 								do 
; 545  : 								{
; 546  : 									POBJECT_TYPE ObjectType = 0;

	mov	r8, r9

; 547  : 									USHORT ObjectTypeIndex = Handles->ObjectTypeIndex;
; 548  : 									int c = 0;

	mov	edi, r9d

; 549  : 									if (ObjectTypeIndex == ThreadIndex)

	cmp	WORD PTR [r12+30], ax
	jne	SHORT $LN20@KQueryHand

; 550  : 									{
; 551  : 										ObjectType = *PsThreadType, c = 1;

	mov	rax, QWORD PTR PsThreadType
	mov	edi, 1

; 552  : 									}

	jmp	SHORT $LN61@KQueryHand
$LN20@KQueryHand:

; 553  : 									else if (ObjectTypeIndex == ProcessIndex)

	movzx	eax, BYTE PTR ProcessIndex$1$[rsp]
	cmp	WORD PTR [r12+30], ax
	jne	SHORT $LN22@KQueryHand

; 554  : 									{
; 555  : 										ObjectType = *PsProcessType, c = 2;

	mov	rax, QWORD PTR PsProcessType
	mov	edi, 2

; 556  : 									}

	jmp	SHORT $LN61@KQueryHand
$LN22@KQueryHand:

; 557  : 									else if (ObjectTypeIndex == FileIndex)

	movzx	eax, BYTE PTR tv662[rsp]
	cmp	WORD PTR [r12+30], ax
	jne	SHORT $LN24@KQueryHand

; 558  : 									{
; 559  : 										ObjectType = *IoFileObjectType, c = 3;

	mov	rax, QWORD PTR IoFileObjectType
	mov	edi, 3
$LN61@KQueryHand:

; 560  : 									}
; 561  : 
; 562  : 									PVOID Object = 0;

	mov	r8, QWORD PTR [rax]
$LN24@KQueryHand:
	mov	QWORD PTR Object$2[rsp], r9

; 563  : 									PUNICODE_STRING FileName;
; 564  : 									Handles->Reserved = RtlPointerToOffset(pshti, sz);

	mov	eax, r13d
	sub	eax, esi
	mov	DWORD PTR [r12+36], eax

; 565  : 									PEPROCESS ThreadProcess;
; 566  : 									ULONG_PTR HandleValue = Handles->HandleValue;

	mov	rcx, QWORD PTR [r12+16]
	mov	QWORD PTR HandleValue$11[rsp], rcx

; 567  : 									if (bKernel)

	test	edx, edx
	je	SHORT $LN25@KQueryHand

; 568  : 									{
; 569  : 										HandleValue |= KERNEL_HANDLE_MASK;

	or	rcx, -2147483648			; ffffffff80000000H
	mov	QWORD PTR HandleValue$11[rsp], rcx
$LN25@KQueryHand:

; 570  : 									}
; 571  : 									if (0 <= ObReferenceObjectByHandle((HANDLE)HandleValue, 0, ObjectType, 0, &Object, 0))

	mov	QWORD PTR [rsp+40], r9
	lea	rax, QWORD PTR Object$2[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	xor	edx, edx
	call	QWORD PTR __imp_ObReferenceObjectByHandle
	xor	r9d, r9d
	test	eax, eax
	js	$LN26@KQueryHand

; 572  : 									{
; 573  : 										if (Object == Handles->Object) switch (c)

	mov	rcx, QWORD PTR Object$2[rsp]
	cmp	rcx, QWORD PTR [r12]
	jne	$LN35@KQueryHand
	sub	edi, 1
	je	$LN28@KQueryHand
	sub	edi, 1
	je	$LN30@KQueryHand
	lea	r9, QWORD PTR rcb$1[rsp]
	mov	r8d, r15d
	mov	rdx, rbx
	cmp	edi, 1
	je	SHORT $LN31@KQueryHand

; 611  : 
; 612  : 										default:
; 613  : 											if (0 <= ObQueryNameString(Object, poni, OutputBufferLength, &rcb))

	call	QWORD PTR __imp_ObQueryNameString
	test	eax, eax
	js	$LN35@KQueryHand

; 614  : 											{
; 615  : 												Handles->CreatorBackTraceIndex = (USHORT)(rcb = poni->Name.Length);

	movzx	eax, WORD PTR [rbx]
	mov	DWORD PTR rcb$1[rsp], eax
	mov	WORD PTR [r12+28], ax

; 616  : 												memcpy(sz, poni->Name.Buffer, rcb);

	mov	rdx, QWORD PTR [rbx+8]
$LN65@KQueryHand:

; 617  : 												sz = (PWSTR)RtlOffsetToPointer(sz, rcb);
; 618  : 												OutputBufferLength -= (rcb + (sizeof(PVOID) - 1))&~(sizeof(PVOID)-1);
; 619  : 												poni = (POBJECT_NAME_INFORMATION)(((ULONG_PTR)sz + (sizeof(PVOID) - 1))&~(sizeof(PVOID) - 1));
; 620  : 											}
; 621  : 										}
; 622  : 										ObfDereferenceObject(Object);

	mov	r8, rax
	mov	rcx, r13
	call	memcpy
	mov	eax, DWORD PTR rcb$1[rsp]
	jmp	$LN62@KQueryHand
$LN31@KQueryHand:

; 587  : 											sz = (PWSTR)RtlOffsetToPointer(sz, rcb);
; 588  : 											OutputBufferLength -= (rcb + (sizeof(PVOID) - 1))&~(sizeof(PVOID)-1);
; 589  : 											poni = (POBJECT_NAME_INFORMATION)(((ULONG_PTR)sz + (sizeof(PVOID) - 1))&~(sizeof(PVOID) - 1));
; 590  : 											break;
; 591  : 										case 3:// only for xp (for not hung in ObQueryNameString)
; 592  : 											FileName = &((PFILE_OBJECT)Object)->FileName;

	mov	rdi, QWORD PTR Object$2[rsp]

; 593  : 											if (0 <= ObQueryNameString(((PFILE_OBJECT)Object)->DeviceObject, poni, OutputBufferLength, &rcb))

	mov	rcx, QWORD PTR [rdi+8]
	call	QWORD PTR __imp_ObQueryNameString
	test	eax, eax
	js	SHORT $LN32@KQueryHand

; 594  : 											{
; 595  : 												Handles->CreatorBackTraceIndex = (USHORT)(rcb = poni->Name.Length);

	movzx	eax, WORD PTR [rbx]
	mov	DWORD PTR rcb$1[rsp], eax
	mov	WORD PTR [r12+28], ax

; 596  : 												memcpy(sz, poni->Name.Buffer, rcb);

	mov	r8d, eax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, r13
	call	memcpy

; 597  : 												sz = (PWSTR)RtlOffsetToPointer(sz, rcb);

	mov	eax, DWORD PTR rcb$1[rsp]
	add	r13, rax
	mov	QWORD PTR sz$5[rsp], r13

; 598  : 												OutputBufferLength -= (rcb + (sizeof(PVOID) - 1))&~(sizeof(PVOID)-1);

	add	eax, 7
	and	eax, -8					; fffffff8H
	sub	r15d, eax
	mov	DWORD PTR OutputBufferLength$[rsp], r15d

; 599  : 												poni = (POBJECT_NAME_INFORMATION)(((ULONG_PTR)sz + (sizeof(PVOID) - 1))&~(sizeof(PVOID) - 1));

	lea	rbx, QWORD PTR [r13+7]
	and	rbx, -8
	mov	QWORD PTR poni$6[rsp], rbx
$LN32@KQueryHand:

; 600  : 											}
; 601  : 
; 602  : 											if ((rcb = FileName->Length) <= OutputBufferLength)

	movzx	eax, WORD PTR [rdi+88]
	mov	DWORD PTR rcb$1[rsp], eax
	cmp	eax, r15d
	ja	$LN35@KQueryHand

; 603  : 											{
; 604  : 												Handles->CreatorBackTraceIndex += (USHORT)rcb;

	add	WORD PTR [r12+28], ax

; 605  : 												memcpy(sz, FileName->Buffer, rcb);

	mov	rdx, QWORD PTR [rdi+96]

; 606  : 												sz = (PWSTR)RtlOffsetToPointer(sz, rcb);
; 607  : 												OutputBufferLength -= (rcb + (sizeof(PVOID) - 1))&~(sizeof(PVOID)-1);
; 608  : 												poni = (POBJECT_NAME_INFORMATION)(((ULONG_PTR)sz + (sizeof(PVOID) - 1))&~(sizeof(PVOID) - 1));
; 609  : 											}
; 610  : 											break;

	jmp	$LN65@KQueryHand
$LN30@KQueryHand:

; 578  : 												(DWORD)(ULONG_PTR)PsGetProcessId(ThreadProcess), 
; 579  : 												(DWORD)(ULONG_PTR)PsGetThreadId((PKTHREAD)Object), 
; 580  : 												PsGetThreadTeb((PETHREAD)Object), 
; 581  : 												PsGetProcessImageFileName(ThreadProcess)) << 1;
; 582  : 											goto __common;
; 583  : 										case 2:
; 584  : 											rcb = swprintf(sz, L"%x %S", (DWORD)(ULONG_PTR)PsGetProcessId((PEPROCESS)Object), PsGetProcessImageFileName((PEPROCESS)Object)) << 1;

	mov	rcx, QWORD PTR Object$2[rsp]
	call	QWORD PTR __imp_PsGetProcessImageFileName
	mov	rbx, rax
	mov	rcx, QWORD PTR Object$2[rsp]
	call	QWORD PTR __imp_PsGetProcessId
	mov	r9, rbx
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1M@JGIJAGIL@?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAS@
	mov	rcx, r13
	call	QWORD PTR __imp__swprintf
	jmp	SHORT $LN63@KQueryHand
$LN28@KQueryHand:

; 574  : 										{
; 575  : 										case 1:
; 576  : 											ThreadProcess = PsGetThreadProcess((PETHREAD)Object);

	mov	rcx, QWORD PTR Object$2[rsp]
	call	QWORD PTR __imp_PsGetThreadProcess
	mov	rsi, rax

; 577  : 											rcb = swprintf(sz, L"%x.%x %p %S", 

	mov	rcx, rax
	call	QWORD PTR __imp_PsGetProcessImageFileName
	mov	r14, rax
	mov	rcx, QWORD PTR Object$2[rsp]
	call	QWORD PTR __imp_PsGetThreadTeb
	mov	rdi, rax
	mov	rcx, QWORD PTR Object$2[rsp]
	call	QWORD PTR __imp_PsGetThreadId
	mov	rbx, rax
	mov	rcx, rsi
	call	QWORD PTR __imp_PsGetProcessId
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], rdi
	mov	r9d, ebx
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1BI@MCHDAEEC@?$AA?$CF?$AAx?$AA?4?$AA?$CF?$AAx?$AA?5?$AA?$CF?$AAp?$AA?5?$AA?$CF?$AAS@
	mov	rcx, r13
	call	QWORD PTR __imp__swprintf
	mov	rsi, QWORD PTR pshti$1$[rsp]
	mov	r14d, DWORD PTR n$3[rsp]
$LN63@KQueryHand:

; 585  : __common:
; 586  : 											Handles->CreatorBackTraceIndex = (USHORT)rcb;

	add	eax, eax
	mov	ecx, eax
	mov	DWORD PTR rcb$1[rsp], eax
$__common$68:
	mov	WORD PTR [r12+28], ax
	mov	eax, eax
$LN62@KQueryHand:

; 617  : 												sz = (PWSTR)RtlOffsetToPointer(sz, rcb);
; 618  : 												OutputBufferLength -= (rcb + (sizeof(PVOID) - 1))&~(sizeof(PVOID)-1);
; 619  : 												poni = (POBJECT_NAME_INFORMATION)(((ULONG_PTR)sz + (sizeof(PVOID) - 1))&~(sizeof(PVOID) - 1));
; 620  : 											}
; 621  : 										}
; 622  : 										ObfDereferenceObject(Object);

	add	r13, rax
	add	eax, 7
	and	eax, -8					; fffffff8H
	sub	r15d, eax
	lea	rbx, QWORD PTR [r13+7]
	and	rbx, -8
	mov	QWORD PTR sz$5[rsp], r13
	mov	DWORD PTR OutputBufferLength$[rsp], r15d
	mov	QWORD PTR poni$6[rsp], rbx
$LN35@KQueryHand:
	mov	rcx, QWORD PTR Object$2[rsp]
	call	QWORD PTR __imp_ObfDereferenceObject
	xor	r9d, r9d
$LN26@KQueryHand:

; 623  : 									}
; 624  : 									
; 625  : 									Handles->Object = Object;

	mov	rax, QWORD PTR Object$2[rsp]
	mov	QWORD PTR [r12], rax

; 626  : 
; 627  : 								} while (Handles++, --n && 1024 < OutputBufferLength);

	add	r12, 40					; 00000028H
	mov	QWORD PTR Handles$7[rsp], r12
	add	r14d, -1				; ffffffffH
	mov	DWORD PTR n$3[rsp], r14d
	je	SHORT $LN38@KQueryHand
	cmp	r15d, 1024				; 00000400H
	mov	edx, DWORD PTR tv628[rsp]
	movzx	eax, BYTE PTR ThreadIndex$1$[rsp]
	ja	$LL7@KQueryHand
$LN38@KQueryHand:

; 628  : 
; 629  : 								if (!bKernel) KeUnstackDetachProcess(&as);

	cmp	DWORD PTR tv628[rsp], r9d
	jne	SHORT $LN58@KQueryHand
	lea	rcx, QWORD PTR as$12[rsp]
	call	QWORD PTR __imp_KeUnstackDetachProcess
$LN58@KQueryHand:

; 630  : 							}
; 631  : 						}
; 632  : 					}
; 633  : 				}
; 634  : 				MmUnlockPages(Mdl);

	mov	rdi, QWORD PTR Mdl$1$[rsp]
$LN60@KQueryHand:
	mov	ebx, DWORD PTR status$[rsp]
$LN36@KQueryHand:
	mov	rcx, rdi
	call	QWORD PTR __imp_MmUnlockPages

; 635  : 				IoFreeMdl(Mdl);

	mov	rcx, rdi
	call	QWORD PTR __imp_IoFreeMdl
$LN13@KQueryHand:

; 636  : 			}
; 637  : 
; 638  : 			ObfDereferenceObject(Process);

	mov	rcx, QWORD PTR Process$8[rsp]
	call	QWORD PTR __imp_ObfDereferenceObject
	npad	1
$LN12@KQueryHand:

; 639  : 		}
; 640  : 	}
; 641  : 	__except(EXCEPTION_EXECUTE_HANDLER)
; 642  : 	{
; 643  : 		return GetExceptionCode();
; 644  : 	}
; 645  : 
; 646  : 	return status;

	mov	eax, ebx
	jmp	SHORT $LN1@KQueryHand
$LN42@KQueryHand:
$LN1@KQueryHand:

; 647  : }

	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z ENDP		; NT::KQueryHandles
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?OpenProcessById@NT@@YAJPEAPEAX0@Z
_TEXT	SEGMENT
cid$1 = 32
phProcess$ = 64
pUniqueProcess$ = 72
?OpenProcessById@NT@@YAJPEAPEAX0@Z PROC			; NT::OpenProcessById, COMDAT

; 652  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx
	mov	rdi, rcx

; 653  : 	__try
; 654  : 	{
; 655  : 		ProbeForRead(pUniqueProcess, sizeof(HANDLE), __alignof(HANDLE));

	mov	edx, 8
	mov	r8d, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_ProbeForRead

; 656  : 		CLIENT_ID cid = { *pUniqueProcess };

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR cid$1[rsp], rax
	xor	eax, eax
	mov	QWORD PTR cid$1[rsp+8], rax

; 657  : 		return ZwOpenProcess(phProcess, MAXIMUM_ALLOWED, &zoa, &cid);

	lea	r9, QWORD PTR cid$1[rsp]
	lea	r8, OFFSET FLAT:?zoa@NT@@3U_OBJECT_ATTRIBUTES@1@A ; NT::zoa
	mov	edx, 33554432				; 02000000H
	mov	rcx, rdi
	call	QWORD PTR __imp_ZwOpenProcess
	jmp	SHORT $LN8@OpenProces
$LN6@OpenProces:
$LN8@OpenProces:

; 658  : 	}
; 659  : 	__except(EXCEPTION_EXECUTE_HANDLER)
; 660  : 	{
; 661  : 		return GetExceptionCode();
; 662  : 	}	
; 663  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?OpenProcessById@NT@@YAJPEAPEAX0@Z ENDP			; NT::OpenProcessById
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z
_TEXT	SEGMENT
cid$1 = 32
phThread$ = 64
pcid$ = 72
?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z PROC	; NT::OpenTreadByCID, COMDAT

; 666  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx
	mov	rdi, rcx

; 667  : 	__try
; 668  : 	{
; 669  : 		ProbeForRead(pcid, sizeof(CLIENT_ID), __alignof(CLIENT_ID));

	mov	edx, 16
	lea	r8d, QWORD PTR [rdx-8]
	mov	rcx, rbx
	call	QWORD PTR __imp_ProbeForRead

; 670  : 		CLIENT_ID cid = *pcid;

	movups	xmm0, XMMWORD PTR [rbx]
	movdqu	XMMWORD PTR cid$1[rsp], xmm0

; 671  : 		return ZwOpenThread(phThread, MAXIMUM_ALLOWED, &zoa, &cid);

	lea	r9, QWORD PTR cid$1[rsp]
	lea	r8, OFFSET FLAT:?zoa@NT@@3U_OBJECT_ATTRIBUTES@1@A ; NT::zoa
	mov	edx, 33554432				; 02000000H
	mov	rcx, rdi
	call	QWORD PTR __imp_ZwOpenThread
	jmp	SHORT $LN8@OpenTreadB
$LN6@OpenTreadB:
$LN8@OpenTreadB:

; 672  : 	}
; 673  : 	__except(EXCEPTION_EXECUTE_HANDLER)
; 674  : 	{
; 675  : 		return GetExceptionCode();
; 676  : 	}	
; 677  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z ENDP	; NT::OpenTreadByCID
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?SetProtectedProcess@NT@@YAJH@Z
_TEXT	SEGMENT
bSet$ = 48
?SetProtectedProcess@NT@@YAJH@Z PROC			; NT::SetProtectedProcess, COMDAT

; 682  : {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H

; 683  : 	if (g_protMask)

	cmp	DWORD PTR ?g_protMask@NT@@3KA, 0	; NT::g_protMask
	mov	ebx, ecx
	je	SHORT $LN5@SetProtect

; 684  : 	{
; 685  : 		PLONG pl = (PLONG)RtlOffsetToPointer(IoGetCurrentProcess(), g_protOffset);

	call	QWORD PTR __imp_IoGetCurrentProcess
	mov	r8d, DWORD PTR ?g_protOffset@NT@@3KA	; NT::g_protOffset
	add	r8, rax

; 691  : 		} while (InterlockedCompareExchange(pl, newValue, oldValue) != oldValue);

	prefetchw BYTE PTR [r8]
$LL4@SetProtect:

; 686  : 		LONG oldValue, newValue;
; 687  : 		do 
; 688  : 		{
; 689  : 			oldValue = *pl;
; 690  : 			newValue = bSet ? ((oldValue | g_protMask) & g_protMax)  : (oldValue & ~g_protMask);

	mov	edx, DWORD PTR ?g_protMask@NT@@3KA	; NT::g_protMask
	mov	ecx, edx
	or	ecx, DWORD PTR [r8]
	not	edx
	and	ecx, DWORD PTR ?g_protMax@NT@@3KA	; NT::g_protMax
	and	edx, DWORD PTR [r8]

; 691  : 		} while (InterlockedCompareExchange(pl, newValue, oldValue) != oldValue);

	mov	eax, DWORD PTR [r8]
	test	ebx, ebx
	cmovne	edx, ecx
	lock cmpxchg DWORD PTR [r8], edx
	jne	SHORT $LL4@SetProtect

; 692  : 
; 693  : 		return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN1@SetProtect
$LN5@SetProtect:

; 694  : 	}
; 695  : 
; 696  : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; ffffffffc0000001H
$LN1@SetProtect:

; 697  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?SetProtectedProcess@NT@@YAJH@Z ENDP			; NT::SetProtectedProcess
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z
_TEXT	SEGMENT
Information$ = 48
__formal$ = 80
__formal$ = 88
InputBuffer$ = 96
InputBufferLength$ = 104
OutputBuffer$ = 112
OutputBufferLength$ = 120
IoControlCode$ = 128
IoStatus$ = 136
__formal$ = 144
?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z PROC ; NT::FastIoDeviceControl, COMDAT

; 710  : {

$LN28:
	sub	rsp, 72					; 00000048H

; 711  : 	ULONG_PTR Information = 0;

	and	QWORD PTR Information$[rsp], 0
	mov	r10, r8

; 712  : 	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
; 713  : 
; 714  : 	switch (IoControlCode)

	mov	eax, DWORD PTR IoControlCode$[rsp]
	mov	ecx, -1073741808			; ffffffffc0000010H
	sub	eax, 2228227				; 00220003H
	je	$LN4@FastIoDevi
	sub	eax, 4
	je	$LN5@FastIoDevi
	sub	eax, 3
	je	$LN6@FastIoDevi
	sub	eax, 5
	je	$LN7@FastIoDevi
	sub	eax, 3
	je	SHORT $LN8@FastIoDevi
	sub	eax, 5
	je	SHORT $LN9@FastIoDevi
	sub	eax, 4
	je	SHORT $LN11@FastIoDevi
	sub	eax, 4
	je	SHORT $LN12@FastIoDevi
	cmp	eax, 8
	jne	$LN2@FastIoDevi

; 733  : 		break;
; 734  : 	case IOCTL_OpenThread:
; 735  : 		status = InputBufferLength == sizeof(CLIENT_ID) ? OpenTreadByCID((PHANDLE)&Information, (PCLIENT_ID)InputBuffer) : STATUS_INVALID_PARAMETER;

	cmp	r9d, 16
	jne	$LN14@FastIoDevi
	mov	rdx, r8
	lea	rcx, QWORD PTR Information$[rsp]
	call	?OpenTreadByCID@NT@@YAJPEAPEAXPEAU_CLIENT_ID@1@@Z ; NT::OpenTreadByCID
	jmp	$LN24@FastIoDevi
$LN12@FastIoDevi:

; 739  : 		Information = g_protOffset;
; 740  : 		break;
; 741  : 	case IOCTL_DelProtectedProcess:
; 742  : 		status = SetProtectedProcess(FALSE);

	xor	ecx, ecx

; 743  : 		Information = g_protOffset;

	jmp	SHORT $LN26@FastIoDevi
$LN11@FastIoDevi:

; 736  : 		break;
; 737  : 	case IOCTL_SetProtectedProcess:
; 738  : 		status = SetProtectedProcess(TRUE);

	mov	ecx, 1
$LN26@FastIoDevi:

; 744  : 		break;
; 745  : 	}
; 746  : 
; 747  : 	IoStatus->Status = status;

	call	?SetProtectedProcess@NT@@YAJH@Z		; NT::SetProtectedProcess
	mov	ecx, eax
	mov	eax, DWORD PTR ?g_protOffset@NT@@3KA	; NT::g_protOffset
	mov	QWORD PTR Information$[rsp], rax
	jmp	$LN2@FastIoDevi
$LN9@FastIoDevi:

; 731  : 	case IOCTL_OpenProcess:
; 732  : 		status = InputBufferLength == sizeof(PVOID) ? OpenProcessById((PHANDLE)&Information, (PHANDLE)InputBuffer) : STATUS_INVALID_PARAMETER;

	cmp	r9d, 8
	jne	SHORT $LN14@FastIoDevi
	mov	rdx, r10
	lea	rcx, QWORD PTR Information$[rsp]
	call	?OpenProcessById@NT@@YAJPEAPEAX0@Z	; NT::OpenProcessById
	jmp	$LN24@FastIoDevi
$LN8@FastIoDevi:

; 727  : 		break;
; 728  : 	case IOCTL_QueryHandles:
; 729  : 		status = InputBufferLength == sizeof(FQH) && OutputBufferLength >= 0x100000 ? KQueryHandles((FQH*)InputBuffer, OutputBuffer, OutputBufferLength) : STATUS_INFO_LENGTH_MISMATCH;

	cmp	r9d, 16
	jne	SHORT $LN18@FastIoDevi
	mov	r8d, DWORD PTR OutputBufferLength$[rsp]
	cmp	r8d, 1048576				; 00100000H
	jb	SHORT $LN18@FastIoDevi
	mov	rdx, QWORD PTR OutputBuffer$[rsp]
	mov	rcx, r10
	call	?KQueryHandles@NT@@YAJPEAUFQH@1@PEAXK@Z	; NT::KQueryHandles
	jmp	SHORT $LN24@FastIoDevi
$LN18@FastIoDevi:
	mov	ecx, -1073741820			; ffffffffc0000004H

; 730  : 		break;

	jmp	SHORT $LN2@FastIoDevi
$LN7@FastIoDevi:

; 724  : 		break;
; 725  : 	case IOCTL_QueryMemory:
; 726  : 		status = InputBufferLength == sizeof(ULONG_PTR) && OutputBufferLength == 2*sizeof(ULONG_PTR) ? KQueryMemory((PULONG_PTR)InputBuffer, (PULONG_PTR)OutputBuffer) : STATUS_INVALID_PARAMETER;

	cmp	r9d, 8
	jne	SHORT $LN14@FastIoDevi
	cmp	DWORD PTR OutputBufferLength$[rsp], 16
	jne	SHORT $LN14@FastIoDevi
	mov	rdx, QWORD PTR OutputBuffer$[rsp]
	mov	rcx, r10
	call	?KQueryMemory@NT@@YAJPEA_K0@Z		; NT::KQueryMemory
	jmp	SHORT $LN24@FastIoDevi
$LN6@FastIoDevi:

; 722  : 	case IOCTL_ReadMemory:
; 723  : 		status = InputBufferLength == sizeof(PVOID) ? Read(InputBuffer, OutputBuffer, OutputBufferLength, (PULONG)&Information) : STATUS_INVALID_PARAMETER;

	cmp	r9d, 8
	jne	SHORT $LN14@FastIoDevi
	mov	r8d, DWORD PTR OutputBufferLength$[rsp]
	lea	r9, QWORD PTR Information$[rsp]
	mov	rdx, QWORD PTR OutputBuffer$[rsp]
	mov	rcx, r10
	call	?Read@NT@@YAJPEAX0KPEAK@Z		; NT::Read
	jmp	SHORT $LN24@FastIoDevi
$LN14@FastIoDevi:

; 744  : 		break;
; 745  : 	}
; 746  : 
; 747  : 	IoStatus->Status = status;

	mov	ecx, -1073741811			; ffffffffc000000dH
	jmp	SHORT $LN2@FastIoDevi
$LN5@FastIoDevi:

; 718  : 		break;
; 719  : 	case IOCTL_LookupThreadByThreadId:
; 720  : 		status = LookupById((void**)&Information, (PsLookupXByXId)PsLookupThreadByThreadId, InputBuffer, InputBufferLength, OutputBufferLength);

	mov	eax, DWORD PTR OutputBufferLength$[rsp]
	mov	rdx, QWORD PTR __imp_PsLookupThreadByThreadId
	mov	DWORD PTR [rsp+32], eax

; 721  : 		break;

	jmp	SHORT $LN25@FastIoDevi
$LN4@FastIoDevi:

; 715  : 	{
; 716  : 	case IOCTL_LookupProcessByProcessId:
; 717  : 		status = LookupById((void**)&Information, (PsLookupXByXId)PsLookupProcessByProcessId, InputBuffer, InputBufferLength, OutputBufferLength);

	mov	ecx, DWORD PTR OutputBufferLength$[rsp]
	mov	rdx, QWORD PTR __imp_PsLookupProcessByProcessId
	mov	DWORD PTR [rsp+32], ecx
$LN25@FastIoDevi:

; 744  : 		break;
; 745  : 	}
; 746  : 
; 747  : 	IoStatus->Status = status;

	lea	rcx, QWORD PTR Information$[rsp]
	call	?LookupById@NT@@YAJPEAPEAXP6AJPEAX0@Z1KK@Z ; NT::LookupById
$LN24@FastIoDevi:
	mov	ecx, eax
$LN2@FastIoDevi:
	mov	rdx, QWORD PTR IoStatus$[rsp]

; 748  : 	IoStatus->Information = Information;
; 749  : 
; 750  : 	return TRUE;

	mov	al, 1
	mov	DWORD PTR [rdx], ecx
	mov	rcx, QWORD PTR Information$[rsp]
	mov	QWORD PTR [rdx+8], rcx

; 751  : }

	add	rsp, 72					; 00000048H
	ret	0
?FastIoDeviceControl@NT@@YAEPEAU_FILE_OBJECT@1@EPEAXK1KKPEAU_IO_STATUS_BLOCK@1@PEAU_DEVICE_OBJECT@1@@Z ENDP ; NT::FastIoDeviceControl
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z
_TEXT	SEGMENT
n$ = 32
pu$ = 40
ru$ = 80
Process$ = 80
PsIsProtectedProcess$ = 88
?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z PROC		; NT::FindProtectedBits, COMDAT

; 789  : {

$LN37:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r12, rdx
	mov	r15, rcx

; 790  : 	RtlZeroMemory(Process, PAGE_SIZE);

	xor	edx, edx
	mov	r8d, 4096				; 00001000H
	call	memset

; 791  : 	PLONG pu = (PLONG)Process, qu, ru = 0;

	mov	r14, r15
	xor	ebx, ebx

; 792  : 	ULONG n = PAGE_SIZE >> 2, i;

	mov	esi, 1024				; 00000400H
$LL4@FindProtec:

; 793  : 
; 794  : 	__try 
; 795  : 	{
; 796  : 		do 
; 797  : 		{
; 798  : 			*(qu = pu++) = ~0;

	mov	rdi, r14
	add	r14, 4
	mov	QWORD PTR pu$[rsp], r14
	or	DWORD PTR [rdi], -1

; 799  : 
; 800  : 			if (PsIsProtectedProcess(Process))

	mov	rcx, r15
	call	r12
	test	al, al
	je	SHORT $LN13@FindProtec

; 801  : 			{
; 802  : 				if (ru)

	test	rbx, rbx
	jne	$LN1@FindProtec
$LN14@FindProtec:

; 803  : 				{
; 804  : 					return ;
; 805  : 				}
; 806  : 				ru = qu;

	mov	rbx, rdi
	mov	QWORD PTR ru$[rsp], rbx
$LN13@FindProtec:

; 807  : 			}
; 808  : 
; 809  : 			*qu = 0;

	and	DWORD PTR [rdi], 0

; 810  : 
; 811  : 		} while (--n);

	add	esi, -1					; ffffffffH
	mov	DWORD PTR n$[rsp], esi
	jne	SHORT $LL4@FindProtec

; 812  : 	}
; 813  : 	__except(EXCEPTION_EXECUTE_HANDLER)
; 814  : 	{
; 815  : 		return;
; 816  : 	}
; 817  : 
; 818  : 	if (!ru)

	test	rbx, rbx
	je	$LN1@FindProtec

; 824  : 	LONG mask = 0;

	xor	edi, edi

; 819  : 	{
; 820  : 		return ;
; 821  : 	}
; 822  : 
; 823  : 	i = 31;

	lea	r14d, QWORD PTR [rdi+31]
$LL7@FindProtec:

; 825  : 	do 
; 826  : 	{
; 827  : 		_bittestandset(ru, i);

	bts	DWORD PTR [rbx], r14d

; 828  : 
; 829  : 		if (PsIsProtectedProcess(Process))

	mov	rcx, r15
	call	r12
	test	al, al
	je	SHORT $LN16@FindProtec

; 830  : 		{
; 831  : 			mask |= *ru;

	or	edi, DWORD PTR [rbx]

; 832  : 			n++;

	inc	esi
$LN16@FindProtec:

; 833  : 		}
; 834  : 
; 835  : 		_bittestandreset(ru, i);

	btr	DWORD PTR [rbx], r14d

; 836  : 
; 837  : 	} while (--i);

	add	r14d, -1				; ffffffffH
	jne	SHORT $LL7@FindProtec

; 838  : 
; 839  : 	g_protOffset = RtlPointerToOffset(Process, ru);

	sub	ebx, r15d
	mov	DWORD PTR ?g_protOffset@NT@@3KA, ebx	; NT::g_protOffset

; 840  : 
; 841  : 	switch (n)

	sub	esi, 1
	je	SHORT $LN17@FindProtec
	cmp	esi, 2
	jne	SHORT $LN10@FindProtec

; 845  : 		break;
; 846  : 	case 3:
; 847  : 		switch (mask)

	cmp	edi, 7
	je	SHORT $LN22@FindProtec
	cmp	edi, 1792				; 00000700H
	je	SHORT $LN21@FindProtec
	cmp	edi, 458752				; 00070000H
	je	SHORT $LN20@FindProtec
	cmp	edi, 117440512				; 07000000H
	jne	SHORT $LN10@FindProtec

; 848  : 		{
; 849  : 		case 0x07000000:
; 850  : 			g_protMask = 0xff000000;

	mov	DWORD PTR ?g_protMask@NT@@3KA, -16777216 ; NT::g_protMask, ff000000H

; 851  : 			break;

	jmp	SHORT $LN10@FindProtec
$LN20@FindProtec:

; 852  : 		case 0x00070000:
; 853  : 			g_protMask = 0x00ff0000;

	mov	DWORD PTR ?g_protMask@NT@@3KA, 16711680	; NT::g_protMask, 00ff0000H

; 854  : 			break;

	jmp	SHORT $LN10@FindProtec
$LN21@FindProtec:

; 855  : 		case 0x00000700:
; 856  : 			g_protMask = 0x0000ff00;

	mov	DWORD PTR ?g_protMask@NT@@3KA, 65280	; NT::g_protMask, 0000ff00H

; 857  : 			break;

	jmp	SHORT $LN10@FindProtec
$LN22@FindProtec:

; 858  : 		case 0x00000007:
; 859  : 			g_protMask = 0x000000ff;

	mov	DWORD PTR ?g_protMask@NT@@3KA, 255	; NT::g_protMask, 000000ffH
	jmp	SHORT $LN10@FindProtec
$LN17@FindProtec:

; 842  : 	{
; 843  : 	case 1:
; 844  : 		g_protMask = mask;

	mov	DWORD PTR ?g_protMask@NT@@3KA, edi	; NT::g_protMask
$LN10@FindProtec:

; 860  : 			break;
; 861  : 		}
; 862  : 		break;
; 863  : 	}
; 864  : 
; 865  : 	g_protMax = (*(PULONG)RtlOffsetToPointer(PsInitialSystemProcess, g_protOffset) & g_protMask) | ~g_protMask;

	mov	rax, QWORD PTR __imp_PsInitialSystemProcess
	mov	rcx, QWORD PTR [rax]
	mov	r8d, DWORD PTR [rbx+rcx]
	mov	eax, DWORD PTR ?g_protMask@NT@@3KA	; NT::g_protMask
	and	r8d, eax
	not	eax
	or	r8d, eax
	mov	DWORD PTR ?g_protMax@NT@@3KA, r8d	; NT::g_protMax
	jmp	SHORT $LN1@FindProtec
$LN26@FindProtec:
$LN1@FindProtec:

; 866  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z ENDP		; NT::FindProtectedBits
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?FindProtectedBits@NT@@YAXXZ
_TEXT	SEGMENT
?FindProtectedBits@NT@@YAXXZ PROC			; NT::FindProtectedBits, COMDAT

; 869  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 870  : 	STATIC_UNICODE_STRING_(PsIsProtectedProcess);
; 871  : 
; 872  : 	union {
; 873  : 		PVOID pv;
; 874  : 		BOOLEAN (CALLBACK * fn)(PVOID);
; 875  : 	};
; 876  : 	
; 877  : 	if (pv = MmGetSystemRoutineAddress(const_cast<PUNICODE_STRING>(&PsIsProtectedProcess)))

	lea	rcx, OFFSET FLAT:?PsIsProtectedProcess@?1??FindProtectedBits@NT@@YAXXZ@4U_UNICODE_STRING@2@B
	call	QWORD PTR __imp_MmGetSystemRoutineAddress
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN3@FindProtec

; 878  : 	{
; 879  : 		if (PVOID Process = ExAllocatePool(PagedPool, PAGE_SIZE))

	mov	edx, 4096				; 00001000H
	mov	ecx, 1
	call	QWORD PTR __imp_ExAllocatePool
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN3@FindProtec

; 880  : 		{
; 881  : 			FindProtectedBits(Process, fn);

	mov	rdx, rbx
	mov	rcx, rax
	call	?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z	; NT::FindProtectedBits

; 882  : 
; 883  : 			ExFreePool(Process);

	xor	edx, edx
	mov	rcx, rdi
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN3@FindProtec:

; 884  : 		}
; 885  : 	}
; 886  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?FindProtectedBits@NT@@YAXXZ ENDP			; NT::FindProtectedBits
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT ?FoundSelfMapIndex@NT@@YAHXZ
_TEXT	SEGMENT
?FoundSelfMapIndex@NT@@YAHXZ PROC			; NT::FoundSelfMapIndex, COMDAT

; 895  : {

$LN17:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 896  : 	ULONGLONG cr3 = __readcr3() & CR3_MASK;

	mov	rsi, cr3

; 897  : 	
; 898  : 	//DbgPrint("cr3=%I64x\n", cr3);
; 899  : 
; 900  : 	int n = 0x100;

	mov	edi, 256				; 00000100H
	mov	rbp, 4503599627366400			; 000ffffffffff000H
	and	rsi, rbp

; 901  : 	
; 902  : 	PX_SELFMAP = PX_SELFMAP_MIN;

	mov	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rdi	; NT::PX_SELFMAP

; 903  : 
; 904  : 	ULONGLONG _PX_SELFMAP = 0;

	xor	ebx, ebx
	mov	ecx, edi
$LL4@FoundSelfM:

; 905  : 	do 
; 906  : 	{
; 907  : 		_PTE* pte = PXE(PX_SELFMAP);

	mov	rax, rcx
	mov	rdx, 550831656960			; 0000008040201000H
	imul	rax, rdx
	mov	rdx, -281474976710656			; ffff000000000000H
	add	rax, rdx
	lea	r14, QWORD PTR [rax+rcx*8]

; 908  : 		
; 909  : 		if (MmIsAddressValid(pte))

	mov	rcx, r14
	call	QWORD PTR __imp_MmIsAddressValid
	mov	rcx, QWORD PTR ?PX_SELFMAP@NT@@3_KA	; NT::PX_SELFMAP
	test	al, al
	je	SHORT $LN2@FoundSelfM

; 910  : 		{
; 911  : 			//DbgPrint("%03x %p %I64x\n", PX_SELFMAP, pte, pte->Value);
; 912  : 
; 913  : 			if ((pte->Value & CR3_MASK) == cr3)

	mov	rax, QWORD PTR [r14]
	and	rax, rbp
	cmp	rax, rsi
	jne	SHORT $LN2@FoundSelfM

; 914  : 			{
; 915  : 				if (_PX_SELFMAP)

	test	rbx, rbx
	jne	SHORT $LN12@FoundSelfM

; 918  : 					return FALSE;
; 919  : 				}
; 920  : 				else
; 921  : 				{
; 922  : 					_PX_SELFMAP = PX_SELFMAP;

	mov	rbx, rcx
$LN2@FoundSelfM:

; 923  : 				}
; 924  : 			}
; 925  : 		}
; 926  : 
; 927  : 	} while (++PX_SELFMAP, --n);

	inc	rcx
	mov	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rcx	; NT::PX_SELFMAP
	sub	edi, 1
	jne	SHORT $LL4@FoundSelfM

; 928  : 
; 929  : 	if (_PX_SELFMAP)

	test	rbx, rbx
	je	SHORT $LN9@FoundSelfM

; 930  : 	{
; 931  : 		INIT_PTE_CONSTS(_PX_SELFMAP);

	lea	rdx, QWORD PTR [rbx+33553920]
	mov	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rbx	; NT::PX_SELFMAP
	mov	rcx, rbx
	shl	rdx, 39					; 00000027H
	mov	r8, rbx
	shl	rcx, 30
	shl	r8, 21

; 932  : 
; 933  : 		//DbgPrint("%I64x\n%I64x\n%I64x\n%I64x\n%I64x\n", PX_SELFMAP,PTE_BASE_X64,PDE_BASE_X64,PPE_BASE_X64,PXE_BASE_X64);
; 934  : 
; 935  : 		return TRUE;

	lea	eax, QWORD PTR [rdi+1]
	mov	QWORD PTR ?PTE_BASE_X64@NT@@3_KA, rdx	; NT::PTE_BASE_X64
	add	rdx, rcx
	add	r8, rdx
	shl	rbx, 12
	add	rbx, r8
	mov	QWORD PTR ?PDE_BASE_X64@NT@@3_KA, rdx	; NT::PDE_BASE_X64
	mov	QWORD PTR ?PXE_BASE_X64@NT@@3_KA, rbx	; NT::PXE_BASE_X64
	mov	QWORD PTR ?PPE_BASE_X64@NT@@3_KA, r8	; NT::PPE_BASE_X64
	jmp	SHORT $LN1@FoundSelfM
$LN12@FoundSelfM:

; 916  : 				{
; 917  : 					PX_SELFMAP = 0;

	and	QWORD PTR ?PX_SELFMAP@NT@@3_KA, 0	; NT::PX_SELFMAP
$LN9@FoundSelfM:

; 936  : 	}
; 937  : 
; 938  : 	return FALSE;
; 939  : }

	xor	eax, eax
$LN1@FoundSelfM:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?FoundSelfMapIndex@NT@@YAHXZ ENDP			; NT::FoundSelfMapIndex
_TEXT	ENDS
; Function compile flags: /Ogspy
; File o:\vc\tkn\tkn.cpp
;	COMDAT DriverEntry
_TEXT	SEGMENT
major$ = 112
DriverObject$ = 112
__formal$ = 120
minor$ = 128
DriverEntry PROC					; COMDAT

; 1049 : {

$LN24:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rsi, rcx

; 1050 : 	ULONG major, minor;
; 1051 : 	PsGetVersion(&major, &minor, 0, 0);

	lea	rdx, QWORD PTR [rax+24]
	lea	rcx, QWORD PTR [rax+8]
	xor	r9d, r9d
	xor	r8d, r8d
	call	QWORD PTR __imp_PsGetVersion

; 1052 : 	g_OsVersion = (USHORT)((major << 8) + minor);

	movzx	edx, WORD PTR major$[rsp]
	mov	edi, 256				; 00000100H
	movzx	eax, di
	imul	edx, eax
	add	dx, WORD PTR minor$[rsp]
	mov	WORD PTR ?g_OsVersion@NT@@3GA, dx	; NT::g_OsVersion

; 896  : 	ULONGLONG cr3 = __readcr3() & CR3_MASK;

	mov	rbp, cr3
	mov	r12, 4503599627366400			; 000ffffffffff000H

; 897  : 	
; 898  : 	//DbgPrint("cr3=%I64x\n", cr3);
; 899  : 
; 900  : 	int n = 0x100;
; 901  : 	
; 902  : 	PX_SELFMAP = PX_SELFMAP_MIN;

	mov	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rdi	; NT::PX_SELFMAP
	and	rbp, r12

; 903  : 
; 904  : 	ULONGLONG _PX_SELFMAP = 0;

	mov	ecx, edi
	xor	ebx, ebx
$LL7@DriverEntr:

; 905  : 	do 
; 906  : 	{
; 907  : 		_PTE* pte = PXE(PX_SELFMAP);

	mov	rax, rcx
	mov	rdx, 550831656960			; 0000008040201000H
	imul	rax, rdx
	mov	rdx, -281474976710656			; ffff000000000000H
	add	rax, rdx
	lea	r14, QWORD PTR [rax+rcx*8]

; 908  : 		
; 909  : 		if (MmIsAddressValid(pte))

	mov	rcx, r14
	call	QWORD PTR __imp_MmIsAddressValid
	mov	rcx, QWORD PTR ?PX_SELFMAP@NT@@3_KA	; NT::PX_SELFMAP
	test	al, al
	je	SHORT $LN5@DriverEntr

; 910  : 		{
; 911  : 			//DbgPrint("%03x %p %I64x\n", PX_SELFMAP, pte, pte->Value);
; 912  : 
; 913  : 			if ((pte->Value & CR3_MASK) == cr3)

	mov	rax, QWORD PTR [r14]
	and	rax, r12
	cmp	rax, rbp
	jne	SHORT $LN5@DriverEntr

; 914  : 			{
; 915  : 				if (_PX_SELFMAP)

	test	rbx, rbx
	jne	$LN19@DriverEntr

; 919  : 				}
; 920  : 				else
; 921  : 				{
; 922  : 					_PX_SELFMAP = PX_SELFMAP;

	mov	rbx, rcx
$LN5@DriverEntr:

; 923  : 				}
; 924  : 			}
; 925  : 		}
; 926  : 
; 927  : 	} while (++PX_SELFMAP, --n);

	inc	rcx
	mov	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rcx	; NT::PX_SELFMAP
	sub	edi, 1
	jne	SHORT $LL7@DriverEntr

; 928  : 
; 929  : 	if (_PX_SELFMAP)

	test	rbx, rbx
	je	SHORT $LN12@DriverEntr

; 930  : 	{
; 931  : 		INIT_PTE_CONSTS(_PX_SELFMAP);

	lea	rcx, QWORD PTR [rbx+33553920]
	mov	QWORD PTR ?PX_SELFMAP@NT@@3_KA, rbx	; NT::PX_SELFMAP
	mov	rax, rbx
	shl	rcx, 39					; 00000027H
	mov	rdx, rbx
	shl	rax, 30
	shl	rdx, 21
	mov	QWORD PTR ?PTE_BASE_X64@NT@@3_KA, rcx	; NT::PTE_BASE_X64
	add	rcx, rax
	add	rdx, rcx
	shl	rbx, 12
	add	rbx, rdx
	mov	QWORD PTR ?PDE_BASE_X64@NT@@3_KA, rcx	; NT::PDE_BASE_X64
	mov	QWORD PTR ?PXE_BASE_X64@NT@@3_KA, rbx	; NT::PXE_BASE_X64
	mov	QWORD PTR ?PPE_BASE_X64@NT@@3_KA, rdx	; NT::PPE_BASE_X64
$LN12@DriverEntr:

; 877  : 	if (pv = MmGetSystemRoutineAddress(const_cast<PUNICODE_STRING>(&PsIsProtectedProcess)))

	lea	rcx, OFFSET FLAT:?PsIsProtectedProcess@?1??FindProtectedBits@NT@@YAXXZ@4U_UNICODE_STRING@2@B
	call	QWORD PTR __imp_MmGetSystemRoutineAddress
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN16@DriverEntr

; 878  : 	{
; 879  : 		if (PVOID Process = ExAllocatePool(PagedPool, PAGE_SIZE))

	mov	edx, 4096				; 00001000H
	mov	ecx, 1
	call	QWORD PTR __imp_ExAllocatePool
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN16@DriverEntr

; 880  : 		{
; 881  : 			FindProtectedBits(Process, fn);

	mov	rdx, rbx
	mov	rcx, rax
	call	?FindProtectedBits@NT@@YAXPEAXP6AE0@Z@Z	; NT::FindProtectedBits

; 882  : 
; 883  : 			ExFreePool(Process);

	xor	edx, edx
	mov	rcx, rdi
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN16@DriverEntr:

; 1053 : 
; 1054 : #ifdef _WIN64
; 1055 : 	FoundSelfMapIndex();
; 1056 : #else
; 1057 : 	if (ExIsProcessorFeaturePresent(PF_PAE_ENABLED))
; 1058 : 	{
; 1059 : 		pIsAddressValid = IsAddressValidPAE;
; 1060 : 		pfindFirstNotValidVA = findFirstNotValidVAPAE;
; 1061 : 		PX_SELFMAP = PX_SELFMAP_PAE;
; 1062 : 	}
; 1063 : 	else
; 1064 : 	{
; 1065 : 		pIsAddressValid = IsAddressValidX86;
; 1066 : 		pfindFirstNotValidVA = findFirstNotValidVAX86;
; 1067 : 		FoundSelfMapIndexX86();
; 1068 : 	}	
; 1069 : 
; 1070 : 	if (g_OsVersion <= _WIN32_WINNT_WINXP)
; 1071 : 	{
; 1072 : 		if (PULONG pv = (PULONG)GetKernelBase())
; 1073 : 		{
; 1074 : 			if (PIMAGE_NT_HEADERS pinth = RtlImageNtHeader(pv))
; 1075 : 			{
; 1076 : 				if (pinth->FileHeader.NumberOfSections)
; 1077 : 				{
; 1078 : 					PIMAGE_SECTION_HEADER pish = IMAGE_FIRST_SECTION(pinth);
; 1079 : 					if (major = pish->Misc.VirtualSize)
; 1080 : 					{					
; 1081 : 						static DWORD mask = 0x3E0DD7;
; 1082 : 						if (pv = (PULONG)strnstr(major, RtlOffsetToPointer(pv, pish->VirtualAddress), sizeof(mask), &mask))
; 1083 : 						{
; 1084 : 							pv--;
; 1085 : 
; 1086 : 							//DbgPrint("** %p\n", pv);
; 1087 : 
; 1088 : 							if (PMDL mdl = IoAllocateMdl(pv, sizeof(DWORD), FALSE, FALSE, 0))
; 1089 : 							{
; 1090 : 								MmBuildMdlForNonPagedPool(mdl);
; 1091 : 								CSHORT MdlFlags = mdl->MdlFlags;
; 1092 : 								mdl->MdlFlags |= MDL_PAGES_LOCKED;
; 1093 : 								mdl->MdlFlags &= ~MDL_SOURCE_IS_NONPAGED_POOL;
; 1094 : 								if (pv = (PULONG)MmGetSystemAddressForMdlSafe(mdl, LowPagePriority))
; 1095 : 								{
; 1096 : 									*pv = 0x3F0DD7;
; 1097 : 									MmUnmapLockedPages(pv, mdl);
; 1098 : 								}
; 1099 : 								mdl->MdlFlags = MdlFlags;
; 1100 : 
; 1101 : 								IoFreeMdl(mdl);
; 1102 : 							}
; 1103 : 						}
; 1104 : 					}
; 1105 : 				}
; 1106 : 			}
; 1107 : 		}
; 1108 : 	}
; 1109 : #endif
; 1110 : 
; 1111 : 	FindProtectedBits();
; 1112 : 
; 1113 : 	//DbgPrint("ProtectedBits(%08x %08x %08x)\n", g_protOffset, g_protMask, g_protMax);
; 1114 : 
; 1115 : 	DriverObject->DriverUnload = DriverUnload;

	lea	rax, OFFSET FLAT:?DriverUnload@NT@@YAXPEAU_DRIVER_OBJECT@1@@Z ; NT::DriverUnload

; 1116 : 
; 1117 : 	STATIC_UNICODE_STRING(DeviceName, "\\device\\69766781178D422cA183775611A8EE55");
; 1118 : 
; 1119 : 	static const FAST_IO_DISPATCH s_fiod = { 
; 1120 : 		sizeof FAST_IO_DISPATCH, 0, 0, 0, 0, 0, 0, 0, 0, 0, FastIoDeviceControl 
; 1121 : 	};
; 1122 : 
; 1123 : 	DriverObject->FastIoDispatch = (PFAST_IO_DISPATCH)&s_fiod;
; 1124 : 	DriverObject->MajorFunction[IRP_MJ_CREATE] = OnCreate;
; 1125 : 	DriverObject->MajorFunction[IRP_MJ_CLEANUP] = OnCloseCleanup;
; 1126 : 	DriverObject->MajorFunction[IRP_MJ_CLOSE] = OnCloseCleanup;
; 1127 : 
; 1128 : 	NTSTATUS status = IoCreateDevice(DriverObject, 0,

	mov	r9d, 34					; 00000022H
	mov	QWORD PTR [rsi+104], rax
	lea	r8, OFFSET FLAT:?DeviceName@?1??DriverEntry@@9@4U_UNICODE_STRING@NT@@B
	lea	rax, OFFSET FLAT:?s_fiod@?1??DriverEntry@@9@4U_FAST_IO_DISPATCH@NT@@B
	xor	edx, edx
	mov	QWORD PTR [rsi+80], rax
	mov	rcx, rsi
	lea	rax, OFFSET FLAT:?OnCreate@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z ; NT::OnCreate
	mov	QWORD PTR [rsi+112], rax
	lea	rax, OFFSET FLAT:?OnCloseCleanup@NT@@YAJPEAU_DEVICE_OBJECT@1@PEAU_IRP@1@@Z ; NT::OnCloseCleanup
	mov	QWORD PTR [rsi+256], rax
	mov	QWORD PTR [rsi+128], rax
	lea	rax, OFFSET FLAT:?g_ControlDevice@NT@@3PEAU_DEVICE_OBJECT@1@EA ; NT::g_ControlDevice
	mov	QWORD PTR [rsp+48], rax
	mov	BYTE PTR [rsp+40], 0
	and	DWORD PTR [rsp+32], 0
	call	QWORD PTR __imp_IoCreateDevice

; 1129 : 		(PUNICODE_STRING)&DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &g_ControlDevice);
; 1130 : 
; 1131 : 	if (0 <= status)

	test	eax, eax
	js	SHORT $LN2@DriverEntr

; 1132 : 	{
; 1133 : 		g_ControlDevice->Flags &= ~DO_DEVICE_INITIALIZING;

	mov	rcx, QWORD PTR ?g_ControlDevice@NT@@3PEAU_DEVICE_OBJECT@1@EA ; NT::g_ControlDevice
	btr	DWORD PTR [rcx+48], 7
$LN2@DriverEntr:

; 1134 : 	}
; 1135 : 
; 1136 : 	return status;
; 1137 : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN19@DriverEntr:

; 917  : 					PX_SELFMAP = 0;

	and	QWORD PTR ?PX_SELFMAP@NT@@3_KA, 0	; NT::PX_SELFMAP

; 918  : 					return FALSE;

	jmp	$LN12@DriverEntr
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\inc\km\wdm.h
;	COMDAT MmGetSystemAddressForMdlSafe
_TEXT	SEGMENT
Mdl$ = 64
Priority$dead$ = 72
MmGetSystemAddressForMdlSafe PROC			; COMDAT

; 27731: {

$LN6:
	sub	rsp, 56					; 00000038H

; 27732:     if (Mdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL)) {

	test	BYTE PTR [rcx+10], 5
	je	SHORT $LN2@MmGetSyste

; 27733:         return Mdl->MappedSystemVa;

	mov	rax, QWORD PTR [rcx+24]
	jmp	SHORT $LN3@MmGetSyste
$LN2@MmGetSyste:

; 27734:     } else {
; 27735:         return MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmCached,

	and	DWORD PTR [rsp+40], 0
	xor	r9d, r9d
	and	DWORD PTR [rsp+32], 0
	xor	edx, edx
	lea	r8d, QWORD PTR [r9+1]
	call	QWORD PTR __imp_MmMapLockedPagesSpecifyCache
$LN3@MmGetSyste:

; 27736:                                             NULL, FALSE, Priority);
; 27737:     }
; 27738: }

	add	rsp, 56					; 00000038H
	ret	0
MmGetSystemAddressForMdlSafe ENDP
_TEXT	ENDS
END
